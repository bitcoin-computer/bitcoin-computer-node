"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("elliptic");var t=require("bitcoin-computer-bitcore");var a=require("axios");var s=require("chai");var n=require("mocha");var o=require("pg-promise");var r=require("pg-monitor");require("exponential-backoff");var i=require("dotenv");var c=require("winston");var d=require("hash.js");function l(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var u=l(a);var p=l(o);var h=l(r);var S=l(i);var f=l(d);S.default.config();const{PORT:E="3000",ZMQ_URL:$="tcp://litecoind:28332",CHAIN:R="LTC",NETWORK:b="regtest",BCN_ENV:x="dev",BCN_URL:v="http://127.0.0.1:3000",DEBUG_MODE:g="1",POSTGRES_USER:T="bcn",POSTGRES_PASSWORD:O="bcn",POSTGRES_DB:N="bcn",POSTGRES_HOST:m="127.0.0.1",POSTGRES_PORT:H="5432",RPC_PROTOCOL:_="http",RPC_USER:y="bcn-admin",RPC_PASSWORD:P="kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=",RPC_HOST:C="litecoind",RPC_PORT:w="19332",SERVER_VERSION:I="0.1",DEFAULT_WALLET:q="defaultwallet"}=process.env;const A=process.env.ALLOWED_RPC_METHODS?process.env.ALLOWED_RPC_METHODS.split(",").map((e=>new RegExp(e))):[];var K={PORT:parseInt(E,10),ZMQ_URL:$,CHAIN:R,NETWORK:b,BCN_ENV:x,BCN_URL:v,DEBUG_MODE:parseInt(g,10),POSTGRES_USER:T,POSTGRES_PASSWORD:O,POSTGRES_DB:N,POSTGRES_HOST:m,POSTGRES_PORT:parseInt(H,10),POSTGRES_MAX_PARAM_NUM:1e4,RPC_PROTOCOL:_,RPC_USER:y,RPC_PASSWORD:P,RPC_HOST:C,RPC_PORT:parseInt(w,10),SYNC_HEIGHT:1,SYNC_INTERVAL_CHECK:3e3,SERVER_VERSION:I,DB_CONNECTION_RETRY_TIME:500,SIGNATURE_FRESHNESS_MINUTES:3,DEFAULT_WALLET:q,ALLOWED_RPC_METHODS:A};const{DEBUG_MODE:L}=K;const D=c.createLogger({level:["error","warn","info","http","verbose","debug","silly"][L],format:c.format.json(),transports:[new c.transports.Console({format:c.format.combine(c.format.colorize(),c.format.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),c.format.printf((e=>`[2m${e.timestamp}[0m ${e.level} ${e.message}`)))})],exceptionHandlers:[new c.transports.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new c.transports.File({filename:"logs/rejections.log"})]});const G={maxFiles:1,maxSize:1e5};L>=0&&D.add(new c.transports.File({filename:"error.log",level:"error"})),L>=1&&D.add(new c.transports.File({filename:"logs/warn.log",level:"warn",...G})),L>=2&&D.add(new c.transports.File({filename:"logs/info.log",level:"info",...G})),L>=3&&D.add(new c.transports.File({filename:"logs/http.log",level:"http",...G})),L>=4&&D.add(new c.transports.File({filename:"logs/verbose.log",level:"verbose",...G})),L>=5&&D.add(new c.transports.File({filename:"logs/debug.log",level:"debug",...G}));const{POSTGRES_HOST:B,POSTGRES_PORT:W,POSTGRES_DB:U,POSTGRES_USER:M,POSTGRES_PASSWORD:F,DB_CONNECTION_RETRY_TIME:V}=K;const j={error:(e,t)=>{if(t.cn){const{host:a,port:s,database:n,user:o,password:r}=t.cn;D.debug(`Waiting for db to start { message:${e.message} host:${a}, port:${s}, database:${n}, user:${o}, password: ${r}`)}},noWarnings:!0};"dev"===K.BCN_ENV&&K.DEBUG_MODE>0&&(h.default.isAttached()?h.default.detach():(h.default.attach(j),h.default.setTheme("matrix")));const Y=p.default(j)({host:B,port:W,database:U,user:M,password:F,allowExitOnIdle:!0,idleTimeoutMillis:100});const k=(e,t=Date.now(),a)=>{if(!a){const s=f.default.sha256().update(K.BCN_URL+t).digest("hex");a=e.sign(s).toDER("hex")}const s=[a,e.getPublic().encodeCompressed("hex"),t];return`Bearer ${Buffer.from(s.join(":")).toString("base64")}`};const{UN_P2SH_URL:z}=process.env;const{crypto:X}=t.Bitcoin;const{Random:Z}=X;const Q=(e,t)=>e.length===t.length&&e.slice().sort().every(((e,a)=>e===t.slice().sort()[a]));const J=async(e,t,a)=>u.default.get(`${t}${e}`,{headers:{Authentication:a}});const ee=async(e,t,a,s)=>u.default.post(`${a}${e}`,t,{headers:{Authentication:s}});const te=new e.ec("secp256k1");const ae=te.genKeyPair();const se=ae.getPublic().encodeCompressed("hex");const ne=te.genKeyPair().getPublic().encodeCompressed("hex");describe("app",(()=>{describe("Smart Object API",(()=>{describe("POST /v1/${config.CHAIN}/${config.NETWORK}/revs",(()=>{afterEach((async()=>{await Y.none('DELETE FROM "NonStandard"')})),it("Should return the latest rev for the single input object id",(async()=>{const e=Z.getRandomBuffer(8).toString("hex");const t=Z.getRandomBuffer(8).toString("hex");const a=class{}.toString();const n=class{}.toString();const o=X.Hash.sha256(Buffer.from(a)).toString("hex");const r=X.Hash.sha256(Buffer.from(n)).toString("hex");await Y.none('INSERT INTO "NonStandard" ("id", "rev", "publicKeys", "classHash") VALUES (${id}, ${rev}, ${publicKeys}, ${classHash})',{id:`${e}/0`,rev:`${e}/0`,publicKeys:[se],classHash:o}),await Y.none('INSERT INTO "NonStandard" ("id", "rev", "publicKeys", "classHash") VALUES (${id}, ${rev}, ${publicKeys}, ${classHash2})',{id:`${t}/0`,rev:`${t}/2`,publicKeys:[se],classHash2:r}),await Y.none('INSERT INTO "NonStandard" ("id", "rev", "publicKeys", "classHash") VALUES (${id}, ${rev}, ${publicKeys}, ${classHash})',{id:`${t}/1`,rev:`${t}/1`,publicKeys:[ne],classHash:o});const i=await ee(`/v1/${K.CHAIN}/${K.NETWORK}/revs`,{ids:[`${e}/0`]},z,k(ae));s.expect(i).to.not.be.undefined,s.expect(i.status).eq(200),s.expect(i.data.length).eq(1),s.expect(i.data[0]).eq(`${e}/0`)})),it("Should return the latest revs for an array of ids (without ordering)",(async()=>{const e=Z.getRandomBuffer(8).toString("hex");const t=class{}.toString();const a=class{}.toString();const n=X.Hash.sha256(Buffer.from(t)).toString("hex");const o=X.Hash.sha256(Buffer.from(a)).toString("hex");await Y.none('INSERT INTO "NonStandard" ("id", "rev", "publicKeys", "classHash") VALUES (${id}, ${rev}, ${publicKeys}, ${classHash})',{id:`${e}/0`,rev:`${e}/0`,publicKeys:[se],classHash:n}),await Y.none('INSERT INTO "NonStandard" ("id", "rev", "publicKeys", "classHash") VALUES (${id}, ${rev}, ${publicKeys}, ${classHash})',{id:`${e}/1`,rev:`${e}/1`,publicKeys:[se],classHash:o});const r=await ee(`/v1/${K.CHAIN}/${K.NETWORK}/revs`,{ids:[`${e}/1`,`${e}/0`]},z,k(ae));s.expect(r).to.not.be.undefined,s.expect(r.status).eq(200),s.expect(r.data.length).eq(2),s.expect(r.data.sort()).to.deep.eq([`${e}/1`,`${e}/0`].sort());const i=await ee(`/v1/${K.CHAIN}/${K.NETWORK}/revs`,{ids:[`${e}/0`,`${e}/1`]},z,k(ae));s.expect(i).to.not.be.undefined,s.expect(i.status).eq(200),s.expect(i.data.length).eq(2),s.expect(i.data[0]).eq(`${e}/0`),s.expect(i.data[1]).eq(`${e}/1`)}))})),describe("GET /v1/${config.CHAIN}/${config.NETWORK}/non-standard-utxos",(()=>{describe("Endpoint normal behavior",(()=>{const e=Z.getRandomBuffer(8).toString("hex");const t=Z.getRandomBuffer(8).toString("hex");const a=class{}.toString();const o=class{}.toString();const r=X.Hash.sha256(Buffer.from(a)).toString("hex");const i=X.Hash.sha256(Buffer.from(o)).toString("hex");n.before((async()=>{await Y.none('INSERT INTO "NonStandard" ("id", "rev", "publicKeys", "classHash") VALUES (${id}, ${rev}, ${publicKeys}, ${classHash})',{id:`${e}/0`,rev:`${e}/0`,publicKeys:[se],classHash:r}),await Y.none('INSERT INTO "NonStandard" ("id", "rev", "publicKeys", "classHash") VALUES (${id}, ${rev}, ${publicKeys}, ${classHash})',{id:`${t}/0`,rev:`${t}/2`,publicKeys:[se],classHash:i}),await Y.none('INSERT INTO "NonStandard" ("id", "rev", "publicKeys", "classHash") VALUES (${id}, ${rev}, ${publicKeys}, ${classHash})',{id:`${e}/1`,rev:`${e}/1`,publicKeys:[se],classHash:r})})),after((async()=>{await Y.none('DELETE FROM "NonStandard"')})),it("Should return the latest revs for a given public key",(async()=>{const e=await J(`/v1/${K.CHAIN}/${K.NETWORK}/non-standard-utxos?publicKey=${se}`,z,k(ae));s.expect(e).to.not.be.undefined,s.expect(e.status).eq(200),s.expect(e.data.length).eq(3),s.expect(Q[(e.data[0],e.data[1],`${t}/2`)])})),it("Should return the latest revs for a given contract hash",(async()=>{const e=await J(`/v1/${K.CHAIN}/${K.NETWORK}/non-standard-utxos?classHash=${i}`,z,k(ae));s.expect(e).to.not.be.undefined,s.expect(e.status).eq(200),s.expect(e.data.length).eq(1),s.expect(e.data[0]).to.deep.eq(`${t}/2`)}))})),it("Should return blank if there are no latest revs for the given public key in the database",(async()=>{const e=await J(`/v1/${K.CHAIN}/${K.NETWORK}/non-standard-utxos?publicKey=${se}`,z,k(ae));s.expect(e).to.not.be.undefined,s.expect(e.status).eq(200),s.expect(e.data.length).eq(0)})),it("Should return blank if there are no parameters set",(async()=>{const e=await J(`/v1/${K.CHAIN}/${K.NETWORK}/non-standard-utxos`,z,k(ae));s.expect(e).to.not.be.undefined,s.expect(e.status).eq(200),s.expect(e.data.length).eq(0)})),it("Should return blank if there are latest revs for the given public key in the database",(async()=>{const e=await J(`/v1/${K.CHAIN}/${K.NETWORK}/non-standard-utxos?publicKey=${se}`,z,k(ae));s.expect(e).to.not.be.undefined,s.expect(e.status).eq(200),s.expect(e.data.length).eq(0)}))})),describe("GET /wallet/:address/utxos",(()=>{const e="mzoGRNh55y9j57TPdwRGi3nt9X4CFwpqUS";it("Should return the standard unspent transaction outputs for a given address",(async()=>{const t=await J(`/v1/${K.CHAIN}/${K.NETWORK}/wallet/${e}/utxos`,z,k(ae));s.expect(t).to.not.be.undefined,s.expect(t.status).eq(200),t.data.length&&(s.expect(t.data[0].txid).to.be.a("string"),s.expect(t.data[0].vout).to.be.a("string"),s.expect(t.data[0].address).eq(e),s.expect(t.data[0].scriptPubKey).eq("76a914d3802d2126be127424c647f2e90cfa4a15b49a2388ac"),s.expect(t.data[0].amount).to.be.a("number"),s.expect(t.data[0].satoshis).to.be.a("number"))})),it("Should return [] if the given address does not exist in the database",(async()=>{const e=await J(`/v1/${K.CHAIN}/${K.NETWORK}/wallet/2N7ZZBWXQtoWPvfmmPXcJtDiGxNGLzdsY4N/utxos/`,z,k(ae));s.expect(e).to.not.be.undefined,s.expect(e.status).eq(200),s.expect(e.data.length).eq(0)}))})),describe("GET /address/${address}/balance",(()=>{it("Should return the balance of a given address that exists in the database",(async()=>{const e=await J(`/v1/${K.CHAIN}/${K.NETWORK}/address/mzoGRNh55y9j57TPdwRGi3nt9X4CFwpqUS/balance`,z,k(ae));s.expect(e).to.not.be.undefined,s.expect(e.status).eq(200),s.expect(e.data).to.be.a("number")})),it("Should return 0 if the given address does not exist in the database",(async()=>{const e=await J(`/v1/${K.CHAIN}/${K.NETWORK}/address/2N7ZZBWXQtoWPvfmmPXcJtDiGxNGLzdsY4N/balance/`,z,k(ae));s.expect(e).to.not.be.undefined,s.expect(e.status).eq(200),s.expect(e.data).eq(0)}))}))})),describe("Off Chain Store API",(()=>{describe("GET /:id",(()=>{it("Should return data",(async()=>{const e=Math.random().toString();const a=t.Bitcoin.crypto.Hash.sha256(Buffer.from(e)).toString("hex");await Y.none('INSERT INTO "OffChain"("id", "data") VALUES(${id}, ${data})',{data:e,id:a});const n=await J(`/v1/store/${a}`,z,k(ae));s.expect(n.status).eq(200),s.expect(n.data).to.deep.eq(e),await Y.none('DELETE FROM "OffChain" WHERE "id" = ${id}',{id:a})}))})),describe("POST /",(()=>{it("Should post data",(async()=>{const e={__cls:class{constructor(){this.n=1}}.toString()}.toString();const a={data:e};const n=await ee("/v1/store",a,z,k(ae));s.expect(n.status).eq(201);const o=t.Bitcoin.crypto.Hash.sha256(Buffer.from(e)).toString("hex");s.expect(n.data._url).eq(`${z.toLowerCase()}/store/${o}`);const r=await Y.any('SELECT "id", "data" FROM "OffChain" WHERE id = ${id}',{id:o});s.expect(r.length).eq(1),s.expect(r[0].id).eq(o),s.expect(r[0].data.toString()).eq(e),await Y.none('DELETE FROM "OffChain" WHERE "id" = ${hash}',{hash:o})}))}))}))})),exports.authenticatedDelete=async(e,t,a)=>u.default.delete(`${t}${e}`,{headers:{Authentication:a}}),exports.authenticatedGet=J,exports.authenticatedPost=ee;
