"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("elliptic");var t=require("bitcoin-computer-bitcore");var a=require("axios");var s=require("chai");var n=require("mocha");var o=require("pg-promise");var r=require("pg-monitor");require("exponential-backoff");var i=require("dotenv");var c=require("winston");var d=require("hash.js");function l(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var u=l(a);var p=l(o);var h=l(r);var S=l(i);var f=l(d);S.default.config();const{PORT:E="3000",ZMQ_URL:$="tcp://litecoind:28332",CHAIN:R="LTC",NETWORK:b="regtest",BCN_ENV:x="dev",BCN_URL:T="http://127.0.0.1:3000",DEBUG_MODE:v="1",POSTGRES_USER:g="bcn",POSTGRES_PASSWORD:N="bcn",POSTGRES_DB:O="bcn",POSTGRES_HOST:m="127.0.0.1",POSTGRES_PORT:H="5432",RPC_PROTOCOL:_="http",RPC_USER:y="bcn-admin",RPC_PASSWORD:P="kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=",RPC_HOST:C="litecoind",RPC_PORT:w="19332",SERVER_VERSION:I="0.1",TESTING:q=!1,DEFAULT_WALLET:A="defaultwallet"}=process.env;const K=process.env.ALLOWED_RPC_METHODS?process.env.ALLOWED_RPC_METHODS.split(",").map((e=>new RegExp(e))):[];var L={PORT:parseInt(E,10),ZMQ_URL:$,CHAIN:R,NETWORK:b,BCN_ENV:x,BCN_URL:T,DEBUG_MODE:parseInt(v,10),POSTGRES_USER:g,POSTGRES_PASSWORD:N,POSTGRES_DB:O,POSTGRES_HOST:m,POSTGRES_PORT:parseInt(H,10),POSTGRES_MAX_PARAM_NUM:1e4,RPC_PROTOCOL:_,RPC_USER:y,RPC_PASSWORD:P,RPC_HOST:C,RPC_PORT:parseInt(w,10),SYNC_HEIGHT:1,SYNC_INTERVAL_CHECK:3e3,SERVER_VERSION:I,TESTING:q,DB_CONNECTION_RETRY_TIME:500,SIGNATURE_FRESHNESS_MINUTES:3,DEFAULT_WALLET:A,ALLOWED_RPC_METHODS:K};const{DEBUG_MODE:G}=L;const D=c.createLogger({level:["error","warn","info","http","verbose","debug","silly"][G],format:c.format.json(),transports:[new c.transports.Console({format:c.format.combine(c.format.colorize(),c.format.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),c.format.printf((e=>`[2m${e.timestamp}[0m ${e.level} ${e.message}`)))})],exceptionHandlers:[new c.transports.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new c.transports.File({filename:"logs/rejections.log"})]});const B={maxFiles:1,maxSize:1e5};G>=0&&D.add(new c.transports.File({filename:"error.log",level:"error"})),G>=1&&D.add(new c.transports.File({filename:"logs/warn.log",level:"warn",...B})),G>=2&&D.add(new c.transports.File({filename:"logs/info.log",level:"info",...B})),G>=3&&D.add(new c.transports.File({filename:"logs/http.log",level:"http",...B})),G>=4&&D.add(new c.transports.File({filename:"logs/verbose.log",level:"verbose",...B})),G>=5&&D.add(new c.transports.File({filename:"logs/debug.log",level:"debug",...B}));const{POSTGRES_HOST:W,POSTGRES_PORT:U,POSTGRES_DB:M,POSTGRES_USER:F,POSTGRES_PASSWORD:V,DB_CONNECTION_RETRY_TIME:j}=L;const Y={error:(e,t)=>{if(t.cn){const{host:a,port:s,database:n,user:o,password:r}=t.cn;D.debug(`Waiting for db to start { message:${e.message} host:${a}, port:${s}, database:${n}, user:${o}, password: ${r}`)}},noWarnings:!0};"dev"===L.BCN_ENV&&L.DEBUG_MODE>0&&(h.default.isAttached()?h.default.detach():(h.default.attach(Y),h.default.setTheme("matrix")));const k=p.default(Y)({host:W,port:U,database:M,user:F,password:V,allowExitOnIdle:!0,idleTimeoutMillis:100});const z=(e,t=Date.now(),a)=>{if(!a){const s=f.default.sha256().update(L.BCN_URL+t).digest("hex");a=e.sign(s).toDER("hex")}const s=[a,e.getPublic().encodeCompressed("hex"),t];return`Bearer ${Buffer.from(s.join(":")).toString("base64")}`};const{UN_P2SH_URL:X}=process.env;const{crypto:Z}=t.Bitcoin;const{Random:Q}=Z;const J=(e,t)=>e.length===t.length&&e.slice().sort().every(((e,a)=>e===t.slice().sort()[a]));const ee=async(e,t,a)=>u.default.get(`${t}${e}`,{headers:{Authentication:a}});const te=async(e,t,a,s)=>u.default.post(`${a}${e}`,t,{headers:{Authentication:s}});const ae=new e.ec("secp256k1");const se=ae.genKeyPair();const ne=se.getPublic().encodeCompressed("hex");const oe=ae.genKeyPair().getPublic().encodeCompressed("hex");describe("app",(()=>{describe("Smart Object API",(()=>{describe("POST /v1/${config.CHAIN}/${config.NETWORK}/revs",(()=>{afterEach((async()=>{await k.none('DELETE FROM "NonStandard"')})),it("Should return the latest rev for the single input object id",(async()=>{const e=Q.getRandomBuffer(8).toString("hex");const t=Q.getRandomBuffer(8).toString("hex");const a=class{}.toString();const n=class{}.toString();const o=Z.Hash.sha256(Buffer.from(a)).toString("hex");const r=Z.Hash.sha256(Buffer.from(n)).toString("hex");await k.none('INSERT INTO "NonStandard" ("id", "rev", "publicKeys", "classHash") VALUES (${id}, ${rev}, ${publicKeys}, ${classHash})',{id:`${e}/0`,rev:`${e}/0`,publicKeys:[ne],classHash:o}),await k.none('INSERT INTO "NonStandard" ("id", "rev", "publicKeys", "classHash") VALUES (${id}, ${rev}, ${publicKeys}, ${classHash2})',{id:`${t}/0`,rev:`${t}/2`,publicKeys:[ne],classHash2:r}),await k.none('INSERT INTO "NonStandard" ("id", "rev", "publicKeys", "classHash") VALUES (${id}, ${rev}, ${publicKeys}, ${classHash})',{id:`${t}/1`,rev:`${t}/1`,publicKeys:[oe],classHash:o});const i=await te(`/v1/${L.CHAIN}/${L.NETWORK}/revs`,{ids:[`${e}/0`]},X,z(se));s.expect(i).to.not.be.undefined,s.expect(i.status).eq(200),s.expect(i.data.length).eq(1),s.expect(i.data[0]).eq(`${e}/0`)})),it("Should return the latest revs for an array of ids (without ordering)",(async()=>{const e=Q.getRandomBuffer(8).toString("hex");const t=class{}.toString();const a=class{}.toString();const n=Z.Hash.sha256(Buffer.from(t)).toString("hex");const o=Z.Hash.sha256(Buffer.from(a)).toString("hex");await k.none('INSERT INTO "NonStandard" ("id", "rev", "publicKeys", "classHash") VALUES (${id}, ${rev}, ${publicKeys}, ${classHash})',{id:`${e}/0`,rev:`${e}/0`,publicKeys:[ne],classHash:n}),await k.none('INSERT INTO "NonStandard" ("id", "rev", "publicKeys", "classHash") VALUES (${id}, ${rev}, ${publicKeys}, ${classHash})',{id:`${e}/1`,rev:`${e}/1`,publicKeys:[ne],classHash:o});const r=await te(`/v1/${L.CHAIN}/${L.NETWORK}/revs`,{ids:[`${e}/1`,`${e}/0`]},X,z(se));s.expect(r).to.not.be.undefined,s.expect(r.status).eq(200),s.expect(r.data.length).eq(2),s.expect(r.data.sort()).to.deep.eq([`${e}/1`,`${e}/0`].sort());const i=await te(`/v1/${L.CHAIN}/${L.NETWORK}/revs`,{ids:[`${e}/0`,`${e}/1`]},X,z(se));s.expect(i).to.not.be.undefined,s.expect(i.status).eq(200),s.expect(i.data.length).eq(2),s.expect(i.data[0]).eq(`${e}/0`),s.expect(i.data[1]).eq(`${e}/1`)}))})),describe("GET /v1/${config.CHAIN}/${config.NETWORK}/non-standard-utxos",(()=>{describe("Endpoint normal behavior",(()=>{const e=Q.getRandomBuffer(8).toString("hex");const t=Q.getRandomBuffer(8).toString("hex");const a=class{}.toString();const o=class{}.toString();const r=Z.Hash.sha256(Buffer.from(a)).toString("hex");const i=Z.Hash.sha256(Buffer.from(o)).toString("hex");n.before((async()=>{await k.none('INSERT INTO "NonStandard" ("id", "rev", "publicKeys", "classHash") VALUES (${id}, ${rev}, ${publicKeys}, ${classHash})',{id:`${e}/0`,rev:`${e}/0`,publicKeys:[ne],classHash:r}),await k.none('INSERT INTO "NonStandard" ("id", "rev", "publicKeys", "classHash") VALUES (${id}, ${rev}, ${publicKeys}, ${classHash})',{id:`${t}/0`,rev:`${t}/2`,publicKeys:[ne],classHash:i}),await k.none('INSERT INTO "NonStandard" ("id", "rev", "publicKeys", "classHash") VALUES (${id}, ${rev}, ${publicKeys}, ${classHash})',{id:`${e}/1`,rev:`${e}/1`,publicKeys:[ne],classHash:r})})),after((async()=>{await k.none('DELETE FROM "NonStandard"')})),it("Should return the latest revs for a given public key",(async()=>{const e=await ee(`/v1/${L.CHAIN}/${L.NETWORK}/non-standard-utxos?publicKey=${ne}`,X,z(se));s.expect(e).to.not.be.undefined,s.expect(e.status).eq(200),s.expect(e.data.length).eq(3),s.expect(J[(e.data[0],e.data[1],`${t}/2`)])})),it("Should return the latest revs for a given contract hash",(async()=>{const e=await ee(`/v1/${L.CHAIN}/${L.NETWORK}/non-standard-utxos?classHash=${i}`,X,z(se));s.expect(e).to.not.be.undefined,s.expect(e.status).eq(200),s.expect(e.data.length).eq(1),s.expect(e.data[0]).to.deep.eq(`${t}/2`)}))})),it("Should return blank if there are no latest revs for the given public key in the database",(async()=>{const e=await ee(`/v1/${L.CHAIN}/${L.NETWORK}/non-standard-utxos?publicKey=${ne}`,X,z(se));s.expect(e).to.not.be.undefined,s.expect(e.status).eq(200),s.expect(e.data.length).eq(0)})),it("Should return blank if there are no parameters set",(async()=>{const e=await ee(`/v1/${L.CHAIN}/${L.NETWORK}/non-standard-utxos`,X,z(se));s.expect(e).to.not.be.undefined,s.expect(e.status).eq(200),s.expect(e.data.length).eq(0)})),it("Should return blank if there are latest revs for the given public key in the database",(async()=>{const e=await ee(`/v1/${L.CHAIN}/${L.NETWORK}/non-standard-utxos?publicKey=${ne}`,X,z(se));s.expect(e).to.not.be.undefined,s.expect(e.status).eq(200),s.expect(e.data.length).eq(0)}))})),describe("GET /wallet/:address/utxos",(()=>{const e="mzoGRNh55y9j57TPdwRGi3nt9X4CFwpqUS";it("Should return the standard unspent transaction outputs for a given address",(async()=>{const t=await ee(`/v1/${L.CHAIN}/${L.NETWORK}/wallet/${e}/utxos`,X,z(se));s.expect(t).to.not.be.undefined,s.expect(t.status).eq(200),t.data.length&&(s.expect(t.data[0].txid).to.be.a("string"),s.expect(t.data[0].vout).to.be.a("string"),s.expect(t.data[0].address).eq(e),s.expect(t.data[0].scriptPubKey).eq("76a914d3802d2126be127424c647f2e90cfa4a15b49a2388ac"),s.expect(t.data[0].amount).to.be.a("number"),s.expect(t.data[0].satoshis).to.be.a("number"))})),it("Should return [] if the given address does not exist in the database",(async()=>{const e=await ee(`/v1/${L.CHAIN}/${L.NETWORK}/wallet/2N7ZZBWXQtoWPvfmmPXcJtDiGxNGLzdsY4N/utxos/`,X,z(se));s.expect(e).to.not.be.undefined,s.expect(e.status).eq(200),s.expect(e.data.length).eq(0)}))})),describe("GET /address/${address}/balance",(()=>{it("Should return the balance of a given address that exists in the database",(async()=>{const e=await ee(`/v1/${L.CHAIN}/${L.NETWORK}/address/mzoGRNh55y9j57TPdwRGi3nt9X4CFwpqUS/balance`,X,z(se));s.expect(e).to.not.be.undefined,s.expect(e.status).eq(200),s.expect(e.data).to.be.a("number")})),it("Should return 0 if the given address does not exist in the database",(async()=>{const e=await ee(`/v1/${L.CHAIN}/${L.NETWORK}/address/2N7ZZBWXQtoWPvfmmPXcJtDiGxNGLzdsY4N/balance/`,X,z(se));s.expect(e).to.not.be.undefined,s.expect(e.status).eq(200),s.expect(e.data).eq(0)}))}))})),describe("Off Chain Store API",(()=>{describe("GET /:id",(()=>{it("Should return data",(async()=>{const e=Math.random().toString();const a=t.Bitcoin.crypto.Hash.sha256(Buffer.from(e)).toString("hex");await k.none('INSERT INTO "OffChain"("id", "data") VALUES(${id}, ${data})',{data:e,id:a});const n=await ee(`/v1/store/${a}`,X,z(se));s.expect(n.status).eq(200),s.expect(n.data).to.deep.eq(e),await k.none('DELETE FROM "OffChain" WHERE "id" = ${id}',{id:a})}))})),describe("POST /",(()=>{it("Should post data",(async()=>{const e={__cls:class{constructor(){this.n=1}}.toString()}.toString();const a={data:e};const n=await te("/v1/store",a,X,z(se));s.expect(n.status).eq(201);const o=t.Bitcoin.crypto.Hash.sha256(Buffer.from(e)).toString("hex");s.expect(n.data._url).eq(`${X.toLowerCase()}/store/${o}`);const r=await k.any('SELECT "id", "data" FROM "OffChain" WHERE id = ${id}',{id:o});s.expect(r.length).eq(1),s.expect(r[0].id).eq(o),s.expect(r[0].data.toString()).eq(e),await k.none('DELETE FROM "OffChain" WHERE "id" = ${hash}',{hash:o})}))}))}))})),exports.authenticatedDelete=async(e,t,a)=>u.default.delete(`${t}${e}`,{headers:{Authentication:a}}),exports.authenticatedGet=ee,exports.authenticatedPost=te;
