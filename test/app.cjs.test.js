"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t=require("elliptic");var e=require("bitcoin-computer-bitcore");var a=require("axios");var n=require("crypto");var c=require("pg-promise");var o=require("pg-monitor");var r=require("dotenv");var s=require("winston");require("bitcoind-rpc");var i=require("hash.js");function d(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}var u=d(a);var l=d(n);var p=d(c);var $=d(o);var N=d(r);var h=d(i);N.default.config();const{PORT:f=3e3,ZMQ_URL:S="tcp://litecoind:28332",CHAIN:x="LTC",NETWORK:E="regtest",BCN_ENV:b="dev",BCN_URL:T="http://127.0.0.1:3000",DEBUG_MODE:y=1,POSTGRES_USER:v="bcn",POSTGRES_PASSWORD:m="bcn",POSTGRES_DB:R="bcn",POSTGRES_HOST:B="127.0.0.1",POSTGRES_PORT:O=5432,RPC_PROTOCOL:H="http",RPC_USER:g="bcn-admin",RPC_PASSWORD:K="kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=",RPC_HOST:A="litecoind",RPC_PORT:w=19332,SERVER_VERSION:I=.1,DEFAULT_WALLET:C="defaultwallet"}=process.env;var P={PORT:f,ZMQ_URL:S,CHAIN:x,NETWORK:E,BCN_ENV:b,BCN_URL:T,DEBUG_MODE:y,POSTGRES_USER:v,POSTGRES_PASSWORD:m,POSTGRES_DB:R,POSTGRES_HOST:B,POSTGRES_PORT:O,POSTGRES_MAX_PARAM_NUM:1e4,RPC_PROTOCOL:H,RPC_USER:g,RPC_PASSWORD:K,RPC_HOST:A,RPC_PORT:w,SYNC_HEIGHT:1,SYNC_INTERVAL_CHECK:3e3,SERVER_VERSION:I,DB_CONNECTION_RETRY_TIME:3e3,SIGNATURE_FRESHNESS_MINUTES:3,DEFAULT_WALLET:C};const _=s.createLogger({level:"info",format:s.format.json(),transports:[new s.transports.File({filename:"error.log",level:"error"}),new s.transports.File({filename:"combined.log"})]});_.add(new s.transports.Console({format:s.format.combine(s.format.colorize(),s.format.timestamp({format:"YYYY-MM-DD HH:mm:ss"}),s.format.printf((t=>`${t.level} ${t.message} [2m${t.timestamp}[0m`)))}));const D={error:(t,e)=>{e.cn&&_.info(`Connection to db failed: ${JSON.stringify(e.cn)} ${t}`)},noWarnings:!0};"dev"===P.BCN_ENV&&P.DEBUG_MODE>0&&($.default.isAttached()?$.default.detach():($.default.attach(D),$.default.setTheme("matrix")));const L=p.default(D)({host:P.POSTGRES_HOST,port:P.POSTGRES_PORT,database:P.POSTGRES_DB,user:P.POSTGRES_USER,password:P.POSTGRES_PASSWORD,allowExitOnIdle:!0,idleTimeoutMillis:100});const W=(t,e=Date.now(),a)=>{if(!a){const n=h.default.sha256().update(P.BCN_URL+e).digest("hex");a=t.sign(n).toDER("hex")}const n=[a,t.getPublic().encodeCompressed("hex"),e];return`Bearer ${Buffer.from(n.join(":")).toString("base64")}`};const{UN_P2SH_URL:U}=process.env;const G=(t,e)=>t.length===e.length&&t.slice().sort().every(((t,a)=>t===e.slice().sort()[a]));const V=async(t,e,a)=>u.default.get(`${e}${t}`,{headers:{Authentication:a}});const q=async(t,e,a,n)=>u.default.post(`${a}${t}`,e,{headers:{Authentication:n}});const M=new t.ec("secp256k1");const F=M.genKeyPair();const k=F.getPublic().encodeCompressed("hex");const Y=M.genKeyPair().getPublic().encodeCompressed("hex");const j=M.genKeyPair().getPublic().encodeCompressed("hex");describe("app",(()=>{describe("Smart Object API",(()=>{describe("GET /wallet/${publicKey}/non-standard-utxos",(()=>{it("Should return the non-standard unspent transaction output for a given public key",(async()=>{const t=l.default.randomBytes(32).toString("hex");const e=l.default.randomBytes(32).toString("hex");const a="b0163f919eb1391f4ba124cf2a3c3e20d84e5eb08ff75a24dd487ff7ed5120f1";const n="c3a8ee4ad98a9b9dbf4b6c3a993ec0fa5a07a5fa64824225074a42875a724473";await L.none('INSERT INTO "NonStandardTxos" ("id", "rev", "publicKeys", "contractName", "contractHash") VALUES (${id}, ${rev}, ${publicKeys}, ${contractName}, ${contractHash})',{id:`${t}/0`,rev:`${t}/0`,publicKeys:[k],contractName:"A",contractHash:a}),await L.none('INSERT INTO "NonStandardTxos" ("id", "rev", "publicKeys", "contractName", "contractHash") VALUES (${id}, ${rev}, ${publicKeys}, ${contractName2}, ${contractHash2})',{id:`${e}/0`,rev:`${e}/2`,publicKeys:[k],contractName2:"B",contractHash2:n}),await L.none('INSERT INTO "NonStandardTxos" ("id", "rev", "publicKeys", "contractName", "contractHash") VALUES (${id}, ${rev}, ${publicKeys}, ${contractName}, ${contractHash})',{id:`${e}/1`,rev:`${e}/1`,publicKeys:[Y],contractName:"A",contractHash:a});const c=await V(`/v1/${P.CHAIN}/${P.NETWORK}/wallet/${k}/non-standard-utxos`,U,W(F));expect(c).toBeDefined(),expect(c.status).toBe(200),expect(c.data.length).toBe(2),expect(c.data[0]).toEqual({rev:expect.any(String),contractName:expect.any(String),contractHash:expect.any(String)}),expect(c.data[1]).toEqual({rev:expect.any(String),contractName:expect.any(String),contractHash:expect.any(String)}),expect(G([c.data[0].rev,c.data[1].rev],[`${t}/0`,`${e}/2`])),expect(G([c.data[0].contractName,c.data[1].contractName],["A","B"])),expect(G([c.data[0].contractHash,c.data[1].contractHash],[a,n])),await L.none('DELETE FROM "NonStandardTxos" WHERE ${publicKey} = ANY ("publicKeys")',{publicKey:k}),await L.none('DELETE FROM "NonStandardTxos" WHERE ${publicKey} = ANY ("publicKeys")',{publicKey:Y})})),it("Should return blank if there are no non-standard unspent transaction outputs for the given public key in the database",(async()=>{const t=await V(`/v1/${P.CHAIN}/${P.NETWORK}/wallet/${j}/non-standard-utxos`,U,W(F));expect(t).toBeDefined(),expect(t.status).toBe(200),expect(t.data.length).toBe(0)}))})),describe("POST /v1/${config.CHAIN}/${config.NETWORK}/revs",(()=>{afterEach((async()=>{await L.none('DELETE FROM "NonStandardTxos"')})),it("Should return the latest rev for the single input object id",(async()=>{const t=l.default.randomBytes(32).toString("hex");const e=l.default.randomBytes(32).toString("hex");const a="b0163f919eb1391f4ba124cf2a3c3e20d84e5eb08ff75a24dd487ff7ed5120f1";await L.none('INSERT INTO "NonStandardTxos" ("id", "rev", "publicKeys", "contractName", "contractHash") VALUES (${id}, ${rev}, ${publicKeys}, ${contractName}, ${contractHash})',{id:`${t}/0`,rev:`${t}/0`,publicKeys:[k],contractName:"A",contractHash:a}),await L.none('INSERT INTO "NonStandardTxos" ("id", "rev", "publicKeys", "contractName", "contractHash") VALUES (${id}, ${rev}, ${publicKeys}, ${contractName2}, ${contractHash2})',{id:`${e}/0`,rev:`${e}/2`,publicKeys:[k],contractName2:"B",contractHash2:"c3a8ee4ad98a9b9dbf4b6c3a993ec0fa5a07a5fa64824225074a42875a724473"}),await L.none('INSERT INTO "NonStandardTxos" ("id", "rev", "publicKeys", "contractName", "contractHash") VALUES (${id}, ${rev}, ${publicKeys}, ${contractName}, ${contractHash})',{id:`${e}/1`,rev:`${e}/1`,publicKeys:[Y],contractName:"A",contractHash:a});const n=await q(`/v1/${P.CHAIN}/${P.NETWORK}/revs`,{ids:[`${t}/0`]},U,W(F));expect(n).toBeDefined(),expect(n.status).toBe(200),expect(n.data.length).toBe(1),expect(n.data[0]).toBe(`${t}/0`)})),it("Should return the latest revs for an array of ids (without ordering)",(async()=>{const t=l.default.randomBytes(32).toString("hex");await L.none('INSERT INTO "NonStandardTxos" ("id", "rev", "publicKeys", "contractName", "contractHash") VALUES (${id}, ${rev}, ${publicKeys}, ${contractName}, ${contractHash})',{id:`${t}/0`,rev:`${t}/0`,publicKeys:[k],contractName:"A",contractHash:"b0163f919eb1391f4ba124cf2a3c3e20d84e5eb08ff75a24dd487ff7ed5120f1"}),await L.none('INSERT INTO "NonStandardTxos" ("id", "rev", "publicKeys", "contractName", "contractHash") VALUES (${id}, ${rev}, ${publicKeys}, ${contractName}, ${contractHash})',{id:`${t}/1`,rev:`${t}/1`,publicKeys:[k],contractName:"B",contractHash:"c3a8ee4ad98a9b9dbf4b6c3a993ec0fa5a07a5fa64824225074a42875a724473"});const e=await q(`/v1/${P.CHAIN}/${P.NETWORK}/revs`,{ids:[`${t}/1`,`${t}/0`]},U,W(F));expect(e).toBeDefined(),expect(e.status).toBe(200),expect(e.data.length).toBe(2),expect(e.data.sort()).toEqual([`${t}/1`,`${t}/0`].sort());const a=await q(`/v1/${P.CHAIN}/${P.NETWORK}/revs`,{ids:[`${t}/0`,`${t}/1`]},U,W(F));expect(a).toBeDefined(),expect(a.status).toBe(200),expect(a.data.length).toBe(2),expect(a.data[0]).toBe(`${t}/0`),expect(a.data[1]).toBe(`${t}/1`)}))})),describe("GET /v1/${config.CHAIN}/${config.NETWORK}/rev/:id/:outNum",(()=>{afterEach((async()=>{await L.none('DELETE FROM "NonStandardTxos"')})),it("Should return revision for a given single input object id",(async()=>{const t=l.default.randomBytes(32).toString("hex");const e=l.default.randomBytes(32).toString("hex");const a="b0163f919eb1391f4ba124cf2a3c3e20d84e5eb08ff75a24dd487ff7ed5120f1";await L.none('INSERT INTO "NonStandardTxos" ("id", "rev", "publicKeys", "contractName", "contractHash") VALUES (${id}, ${rev}, ${publicKeys}, ${contractName}, ${contractHash})',{id:`${t}/0`,rev:`${t}/0`,publicKeys:[k],contractName:"A",contractHash:a}),await L.none('INSERT INTO "NonStandardTxos" ("id", "rev", "publicKeys", "contractName", "contractHash") VALUES (${id}, ${rev}, ${publicKeys}, ${contractName2}, ${contractHash2})',{id:`${e}/0`,rev:`${e}/2`,publicKeys:[k],contractName2:"B",contractHash2:"c3a8ee4ad98a9b9dbf4b6c3a993ec0fa5a07a5fa64824225074a42875a724473"}),await L.none('INSERT INTO "NonStandardTxos" ("id", "rev", "publicKeys", "contractName", "contractHash") VALUES (${id}, ${rev}, ${publicKeys}, ${contractName}, ${contractHash})',{id:`${e}/1`,rev:`${e}/1`,publicKeys:[Y],contractName:"A",contractHash:a});const n=await V(`/v1/${P.CHAIN}/${P.NETWORK}/rev/${e}/1`,U,W(F));expect(n).toBeDefined(),expect(n.status).toBe(200),expect(n.data.length).toBe(1),expect(n.data[0]).toEqual({rev:`${e}/1`})})),it("Should return an empty element if the id or output dont exist on the database",(async()=>{const t=l.default.randomBytes(32).toString("hex");const e=l.default.randomBytes(32).toString("hex");await L.none('INSERT INTO "NonStandardTxos" ("id", "rev", "publicKeys", "contractName", "contractHash") VALUES (${id}, ${rev}, ${publicKeys}, ${contractName}, ${contractHash})',{id:`${t}/0`,rev:`${t}/0`,publicKeys:[k],contractName:"",contractHash:""});const a=await V(`/v1/${P.CHAIN}/${P.NETWORK}/rev/${t}/1`,U,W(F));expect(a).toBeDefined(),expect(a.status).toBe(200),expect(a.data.length).toBe(0);const n=await V(`/v1/${P.CHAIN}/${P.NETWORK}/rev/${e}/1`,U,W(F));expect(n).toBeDefined(),expect(n.status).toBe(200),expect(n.data.length).toBe(0)}))})),describe("GET /v1/${config.CHAIN}/${config.NETWORK}/non-standard-utxos",(()=>{describe("Endpoint normal behavior",(()=>{const t=l.default.randomBytes(32).toString("hex");const e=l.default.randomBytes(32).toString("hex");const a=l.default.randomBytes(32).toString("hex");const n=l.default.randomBytes(32).toString("hex");const c=l.default.randomBytes(32).toString("hex");const o=l.default.randomBytes(32).toString("hex");beforeAll((async()=>{await L.none('INSERT INTO "NonStandardTxos" ("id", "rev", "publicKeys", "contractName", "contractHash") VALUES (${id}, ${rev}, ${publicKeys}, ${contractName}, ${contractHash})',{id:`${t}/0`,rev:`${t}/0`,publicKeys:[k],contractName:a,contractHash:n}),await L.none('INSERT INTO "NonStandardTxos" ("id", "rev", "publicKeys", "contractName", "contractHash") VALUES (${id}, ${rev}, ${publicKeys}, ${contractName2}, ${contractHash2})',{id:`${e}/0`,rev:`${e}/2`,publicKeys:[k],contractName2:c,contractHash2:o}),await L.none('INSERT INTO "NonStandardTxos" ("id", "rev", "publicKeys", "contractName", "contractHash") VALUES (${id}, ${rev}, ${publicKeys}, ${contractName}, ${contractHash})',{id:`${t}/1`,rev:`${t}/1`,publicKeys:[k],contractName:a,contractHash:n})})),afterAll((async()=>{await L.none('DELETE FROM "NonStandardTxos"')})),it("Should return the latest revs for a given public key",(async()=>{const t=await V(`/v1/${P.CHAIN}/${P.NETWORK}/non-standard-utxos?publicKey=${k}`,U,W(F));expect(t).toBeDefined(),expect(t.status).toBe(200),expect(t.data.length).toBe(3),expect(G[(t.data[0],t.data[1],`${e}/2`)])})),it("Should return the latest revs for a given contract name",(async()=>{const e=await V(`/v1/${P.CHAIN}/${P.NETWORK}/non-standard-utxos?contractName=${a}`,U,W(F));expect(e).toBeDefined(),expect(e.status).toBe(200),expect(e.data.length).toBe(2),expect(e.data[0]).toEqual(`${t}/0`)})),it("Should return the latest revs for a given contract hash",(async()=>{const t=await V(`/v1/${P.CHAIN}/${P.NETWORK}/non-standard-utxos?contractHash=${o}`,U,W(F));expect(t).toBeDefined(),expect(t.status).toBe(200),expect(t.data.length).toBe(1),expect(t.data[0]).toEqual(`${e}/2`)}))})),it("Should return blank if there are no latest revs for the given public key in the database",(async()=>{const t=await V(`/v1/${P.CHAIN}/${P.NETWORK}/non-standard-utxos?publicKey=${k}`,U,W(F));expect(t).toBeDefined(),expect(t.status).toBe(200),expect(t.data.length).toBe(0)})),it("Should return blank if there are no parameters set",(async()=>{const t=await V(`/v1/${P.CHAIN}/${P.NETWORK}/non-standard-utxos`,U,W(F));expect(t).toBeDefined(),expect(t.status).toBe(200),expect(t.data.length).toBe(0)})),it("Should return blank if there are latest revs for the given public key in the database",(async()=>{const t=await V(`/v1/${P.CHAIN}/${P.NETWORK}/non-standard-utxos?publicKey=${k}`,U,W(F));expect(t).toBeDefined(),expect(t.status).toBe(200),expect(t.data.length).toBe(0)}))})),describe("GET /wallet/:address/utxos",(()=>{const t="mzoGRNh55y9j57TPdwRGi3nt9X4CFwpqUS";it("Should return the standard unspent transaction outputs for a given address",(async()=>{const e=await V(`/v1/${P.CHAIN}/${P.NETWORK}/wallet/${t}/utxos`,U,W(F));expect(e).toBeDefined(),expect(e.status).toBe(200),e.data.length&&expect(e.data[0]).toEqual({txid:expect.any(String),vout:expect.any(Number),address:t,scriptPubKey:"76a914d3802d2126be127424c647f2e90cfa4a15b49a2388ac",amount:expect.any(Number),satoshis:expect.any(Number)})})),it("Should return [] if the given address does not exist in the database",(async()=>{const t=await V(`/v1/${P.CHAIN}/${P.NETWORK}/wallet/2N7ZZBWXQtoWPvfmmPXcJtDiGxNGLzdsY4N/utxos/`,U,W(F));expect(t).toBeDefined(),expect(t.status).toBe(200),expect(t.data.length).toBe(0)}))})),describe("GET /address/${address}/balance",(()=>{it("Should return the balance of a given address that exists in the database",(async()=>{const t=await V(`/v1/${P.CHAIN}/${P.NETWORK}/address/mzoGRNh55y9j57TPdwRGi3nt9X4CFwpqUS/balance`,U,W(F));expect(t).toBeDefined(),expect(t.status).toBe(200),expect(t.data).toEqual(expect.any(Number))})),it("Should return 0 if the given address does not exist in the database",(async()=>{const t=await V(`/v1/${P.CHAIN}/${P.NETWORK}/address/2N7ZZBWXQtoWPvfmmPXcJtDiGxNGLzdsY4N/balance/`,U,W(F));expect(t).toBeDefined(),expect(t.status).toBe(200),expect(t.data).toBe(0)}))})),describe("Transaction proxy endpoint",(()=>{it("Should throw an error if chain or network as not set correctly",(async()=>{try{await V("/v1/foo/mainnet/tx/bde0e9faecf9507ea7c0e5c588c8aad6c1a71736f7876fcbafbb555ec45e2a72",U,W(F)),expect(0).toBe(1)}catch(t){expect(t.response.status).toBe(404),expect(t.message).toBe("Request failed with status code 404")}})),it("Should return fail if the transaction id does not exist",(async()=>{let t;try{t=await V(`/v1/${P.CHAIN}/${P.NETWORK}/tx/bde0e9faecf9507ea7c0e5c588c8aad6c1a71736f7876fcbafbb555ec45e2a72`,U,W(F))}catch(e){t=e.response,expect(t.status).toBe(500)}}),2e4)}))})),describe("Off Chain Store API",(()=>{describe("GET /:id",(()=>{it("Should return data",(async()=>{const t=Math.random().toString();const a=e.Bitcoin.crypto.Hash.sha256(Buffer.from(t)).toString("hex");await L.none('INSERT INTO "OffChainStore"("id", "data") VALUES(${id}, ${data})',{data:t,id:a});const n=await V(`/v1/store/${a}`,U,W(F));expect(n.status).toBe(200),expect(n.data).toEqual(t),await L.none('DELETE FROM "OffChainStore" WHERE "id" = ${id}',{id:a})}))})),describe("POST /",(()=>{it("Should post data",(async()=>{const t={__cls:class{constructor(){this.n=1}}.toString()}.toString();const a={data:t};const n=await q("/v1/store",a,U,W(F));expect(n.status).toBe(201);const c=e.Bitcoin.crypto.Hash.sha256(Buffer.from(t)).toString("hex");expect(n.data._url).toBe(`${U.toLowerCase()}/store/${c}`);const o=await L.any('SELECT "id", "data" FROM "OffChainStore" WHERE id = ${id}',{id:c});expect(o.length).toBe(1),expect(o[0].id).toBe(c),expect(o[0].data.toString()).toBe(t),await L.none('DELETE FROM "OffChainStore" WHERE "id" = ${hash}',{hash:c})}))}))}))})),exports.authenticatedDelete=async(t,e,a)=>u.default.delete(`${e}${t}`,{headers:{Authentication:a}}),exports.authenticatedGet=V,exports.authenticatedPost=q;
