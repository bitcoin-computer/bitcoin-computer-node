"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("elliptic");var t=require("bitcoin-computer-bitcore");var a=require("axios");var s=require("chai");var n=require("mocha");var o=require("pg-promise");var r=require("pg-monitor");require("exponential-backoff");var i=require("dotenv");var c=require("winston");var d=require("hash.js");function l(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var u=l(a);var p=l(o);var h=l(r);var S=l(i);var f=l(d);S.default.config();const{PORT:$="3000",ZMQ_URL:E="tcp://litecoind:28332",CHAIN:R="LTC",NETWORK:b="regtest",BCN_ENV:x="dev",BCN_URL:g="http://127.0.0.1:3000",DEBUG_MODE:v="1",POSTGRES_USER:N="bcn",POSTGRES_PASSWORD:T="bcn",POSTGRES_DB:O="bcn",POSTGRES_HOST:m="127.0.0.1",POSTGRES_PORT:H="5432",RPC_PROTOCOL:y="http",RPC_USER:_="bcn-admin",RPC_PASSWORD:P="kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=",RPC_HOST:w="litecoind",RPC_PORT:C="19332",SERVER_VERSION:I="0.1",DEFAULT_WALLET:q="defaultwallet"}=process.env;var A={PORT:parseInt($,10),ZMQ_URL:E,CHAIN:R,NETWORK:b,BCN_ENV:x,BCN_URL:g,DEBUG_MODE:parseInt(v,10),POSTGRES_USER:N,POSTGRES_PASSWORD:T,POSTGRES_DB:O,POSTGRES_HOST:m,POSTGRES_PORT:parseInt(H,10),POSTGRES_MAX_PARAM_NUM:1e4,RPC_PROTOCOL:y,RPC_USER:_,RPC_PASSWORD:P,RPC_HOST:w,RPC_PORT:parseInt(C,10),SYNC_HEIGHT:1,SYNC_INTERVAL_CHECK:3e3,SERVER_VERSION:I,DB_CONNECTION_RETRY_TIME:500,SIGNATURE_FRESHNESS_MINUTES:3,DEFAULT_WALLET:q,allowedRPCMethods:[/^get/,/Accounts$/]};const{DEBUG_MODE:K}=A;const G=c.createLogger({level:["error","warn","info","http","verbose","debug","silly"][K],format:c.format.json(),transports:[new c.transports.Console({format:c.format.combine(c.format.colorize(),c.format.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),c.format.printf((e=>`[2m${e.timestamp}[0m ${e.level} ${e.message}`)))})],exceptionHandlers:[new c.transports.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new c.transports.File({filename:"logs/rejections.log"})]});const B={maxFiles:1,maxSize:1e5};K>=0&&G.add(new c.transports.File({filename:"error.log",level:"error"})),K>=1&&G.add(new c.transports.File({filename:"logs/warn.log",level:"warn",...B})),K>=2&&G.add(new c.transports.File({filename:"logs/info.log",level:"info",...B})),K>=3&&G.add(new c.transports.File({filename:"logs/http.log",level:"http",...B})),K>=4&&G.add(new c.transports.File({filename:"logs/verbose.log",level:"verbose",...B})),K>=5&&G.add(new c.transports.File({filename:"logs/debug.log",level:"debug",...B}));const{POSTGRES_HOST:L,POSTGRES_PORT:U,POSTGRES_DB:W,POSTGRES_USER:D,POSTGRES_PASSWORD:M,DB_CONNECTION_RETRY_TIME:F}=A;const V={error:(e,t)=>{if(t.cn){const{host:a,port:s,database:n,user:o,password:r}=t.cn;G.debug(`Waiting for db to start { message:${e.message} host:${a}, port:${s}, database:${n}, user:${o}, password: ${r}`)}},noWarnings:!0};"dev"===A.BCN_ENV&&A.DEBUG_MODE>0&&(h.default.isAttached()?h.default.detach():(h.default.attach(V),h.default.setTheme("matrix")));const j=p.default(V)({host:L,port:U,database:W,user:D,password:M,allowExitOnIdle:!0,idleTimeoutMillis:100});const Y=(e,t=Date.now(),a)=>{if(!a){const s=f.default.sha256().update(A.BCN_URL+t).digest("hex");a=e.sign(s).toDER("hex")}const s=[a,e.getPublic().encodeCompressed("hex"),t];return`Bearer ${Buffer.from(s.join(":")).toString("base64")}`};const{UN_P2SH_URL:k}=process.env;const{crypto:z}=t.Bitcoin;const{Random:X}=z;const Z=(e,t)=>e.length===t.length&&e.slice().sort().every(((e,a)=>e===t.slice().sort()[a]));const Q=async(e,t,a)=>u.default.get(`${t}${e}`,{headers:{Authentication:a}});const J=async(e,t,a,s)=>u.default.post(`${a}${e}`,t,{headers:{Authentication:s}});const ee=new e.ec("secp256k1");const te=ee.genKeyPair();const ae=te.getPublic().encodeCompressed("hex");const se=ee.genKeyPair().getPublic().encodeCompressed("hex");describe("app",(()=>{describe("Smart Object API",(()=>{describe("POST /v1/${config.CHAIN}/${config.NETWORK}/revs",(()=>{afterEach((async()=>{await j.none('DELETE FROM "NonStandard"')})),it("Should return the latest rev for the single input object id",(async()=>{const e=X.getRandomBuffer(8).toString("hex");const t=X.getRandomBuffer(8).toString("hex");const a=class{}.toString();const n=class{}.toString();const o=z.Hash.sha256(Buffer.from(a)).toString("hex");const r=z.Hash.sha256(Buffer.from(n)).toString("hex");await j.none('INSERT INTO "NonStandard" ("id", "rev", "publicKeys", "classHash") VALUES (${id}, ${rev}, ${publicKeys}, ${classHash})',{id:`${e}/0`,rev:`${e}/0`,publicKeys:[ae],classHash:o}),await j.none('INSERT INTO "NonStandard" ("id", "rev", "publicKeys", "classHash") VALUES (${id}, ${rev}, ${publicKeys}, ${classHash2})',{id:`${t}/0`,rev:`${t}/2`,publicKeys:[ae],classHash2:r}),await j.none('INSERT INTO "NonStandard" ("id", "rev", "publicKeys", "classHash") VALUES (${id}, ${rev}, ${publicKeys}, ${classHash})',{id:`${t}/1`,rev:`${t}/1`,publicKeys:[se],classHash:o});const i=await J(`/v1/${A.CHAIN}/${A.NETWORK}/revs`,{ids:[`${e}/0`]},k,Y(te));s.expect(i).to.not.be.undefined,s.expect(i.status).eq(200),s.expect(i.data.length).eq(1),s.expect(i.data[0]).eq(`${e}/0`)})),it("Should return the latest revs for an array of ids (without ordering)",(async()=>{const e=X.getRandomBuffer(8).toString("hex");const t=class{}.toString();const a=class{}.toString();const n=z.Hash.sha256(Buffer.from(t)).toString("hex");const o=z.Hash.sha256(Buffer.from(a)).toString("hex");await j.none('INSERT INTO "NonStandard" ("id", "rev", "publicKeys", "classHash") VALUES (${id}, ${rev}, ${publicKeys}, ${classHash})',{id:`${e}/0`,rev:`${e}/0`,publicKeys:[ae],classHash:n}),await j.none('INSERT INTO "NonStandard" ("id", "rev", "publicKeys", "classHash") VALUES (${id}, ${rev}, ${publicKeys}, ${classHash})',{id:`${e}/1`,rev:`${e}/1`,publicKeys:[ae],classHash:o});const r=await J(`/v1/${A.CHAIN}/${A.NETWORK}/revs`,{ids:[`${e}/1`,`${e}/0`]},k,Y(te));s.expect(r).to.not.be.undefined,s.expect(r.status).eq(200),s.expect(r.data.length).eq(2),s.expect(r.data.sort()).to.deep.eq([`${e}/1`,`${e}/0`].sort());const i=await J(`/v1/${A.CHAIN}/${A.NETWORK}/revs`,{ids:[`${e}/0`,`${e}/1`]},k,Y(te));s.expect(i).to.not.be.undefined,s.expect(i.status).eq(200),s.expect(i.data.length).eq(2),s.expect(i.data[0]).eq(`${e}/0`),s.expect(i.data[1]).eq(`${e}/1`)}))})),describe("GET /v1/${config.CHAIN}/${config.NETWORK}/non-standard-utxos",(()=>{describe("Endpoint normal behavior",(()=>{const e=X.getRandomBuffer(8).toString("hex");const t=X.getRandomBuffer(8).toString("hex");const a=class{}.toString();const o=class{}.toString();const r=z.Hash.sha256(Buffer.from(a)).toString("hex");const i=z.Hash.sha256(Buffer.from(o)).toString("hex");n.before((async()=>{await j.none('INSERT INTO "NonStandard" ("id", "rev", "publicKeys", "classHash") VALUES (${id}, ${rev}, ${publicKeys}, ${classHash})',{id:`${e}/0`,rev:`${e}/0`,publicKeys:[ae],classHash:r}),await j.none('INSERT INTO "NonStandard" ("id", "rev", "publicKeys", "classHash") VALUES (${id}, ${rev}, ${publicKeys}, ${classHash})',{id:`${t}/0`,rev:`${t}/2`,publicKeys:[ae],classHash:i}),await j.none('INSERT INTO "NonStandard" ("id", "rev", "publicKeys", "classHash") VALUES (${id}, ${rev}, ${publicKeys}, ${classHash})',{id:`${e}/1`,rev:`${e}/1`,publicKeys:[ae],classHash:r})})),after((async()=>{await j.none('DELETE FROM "NonStandard"')})),it("Should return the latest revs for a given public key",(async()=>{const e=await Q(`/v1/${A.CHAIN}/${A.NETWORK}/non-standard-utxos?publicKey=${ae}`,k,Y(te));s.expect(e).to.not.be.undefined,s.expect(e.status).eq(200),s.expect(e.data.length).eq(3),s.expect(Z[(e.data[0],e.data[1],`${t}/2`)])})),it("Should return the latest revs for a given contract hash",(async()=>{const e=await Q(`/v1/${A.CHAIN}/${A.NETWORK}/non-standard-utxos?classHash=${i}`,k,Y(te));s.expect(e).to.not.be.undefined,s.expect(e.status).eq(200),s.expect(e.data.length).eq(1),s.expect(e.data[0]).to.deep.eq(`${t}/2`)}))})),it("Should return blank if there are no latest revs for the given public key in the database",(async()=>{const e=await Q(`/v1/${A.CHAIN}/${A.NETWORK}/non-standard-utxos?publicKey=${ae}`,k,Y(te));s.expect(e).to.not.be.undefined,s.expect(e.status).eq(200),s.expect(e.data.length).eq(0)})),it("Should return blank if there are no parameters set",(async()=>{const e=await Q(`/v1/${A.CHAIN}/${A.NETWORK}/non-standard-utxos`,k,Y(te));s.expect(e).to.not.be.undefined,s.expect(e.status).eq(200),s.expect(e.data.length).eq(0)})),it("Should return blank if there are latest revs for the given public key in the database",(async()=>{const e=await Q(`/v1/${A.CHAIN}/${A.NETWORK}/non-standard-utxos?publicKey=${ae}`,k,Y(te));s.expect(e).to.not.be.undefined,s.expect(e.status).eq(200),s.expect(e.data.length).eq(0)}))})),describe("GET /wallet/:address/utxos",(()=>{const e="mzoGRNh55y9j57TPdwRGi3nt9X4CFwpqUS";it("Should return the standard unspent transaction outputs for a given address",(async()=>{const t=await Q(`/v1/${A.CHAIN}/${A.NETWORK}/wallet/${e}/utxos`,k,Y(te));s.expect(t).to.not.be.undefined,s.expect(t.status).eq(200),t.data.length&&(s.expect(t.data[0].txid).to.be.a("string"),s.expect(t.data[0].vout).to.be.a("string"),s.expect(t.data[0].address).eq(e),s.expect(t.data[0].scriptPubKey).eq("76a914d3802d2126be127424c647f2e90cfa4a15b49a2388ac"),s.expect(t.data[0].amount).to.be.a("number"),s.expect(t.data[0].satoshis).to.be.a("number"))})),it("Should return [] if the given address does not exist in the database",(async()=>{const e=await Q(`/v1/${A.CHAIN}/${A.NETWORK}/wallet/2N7ZZBWXQtoWPvfmmPXcJtDiGxNGLzdsY4N/utxos/`,k,Y(te));s.expect(e).to.not.be.undefined,s.expect(e.status).eq(200),s.expect(e.data.length).eq(0)}))})),describe("GET /address/${address}/balance",(()=>{it("Should return the balance of a given address that exists in the database",(async()=>{const e=await Q(`/v1/${A.CHAIN}/${A.NETWORK}/address/mzoGRNh55y9j57TPdwRGi3nt9X4CFwpqUS/balance`,k,Y(te));s.expect(e).to.not.be.undefined,s.expect(e.status).eq(200),s.expect(e.data).to.be.a("number")})),it("Should return 0 if the given address does not exist in the database",(async()=>{const e=await Q(`/v1/${A.CHAIN}/${A.NETWORK}/address/2N7ZZBWXQtoWPvfmmPXcJtDiGxNGLzdsY4N/balance/`,k,Y(te));s.expect(e).to.not.be.undefined,s.expect(e.status).eq(200),s.expect(e.data).eq(0)}))}))})),describe("Off Chain Store API",(()=>{describe("GET /:id",(()=>{it("Should return data",(async()=>{const e=Math.random().toString();const a=t.Bitcoin.crypto.Hash.sha256(Buffer.from(e)).toString("hex");await j.none('INSERT INTO "OffChain"("id", "data") VALUES(${id}, ${data})',{data:e,id:a});const n=await Q(`/v1/store/${a}`,k,Y(te));s.expect(n.status).eq(200),s.expect(n.data).to.deep.eq(e),await j.none('DELETE FROM "OffChain" WHERE "id" = ${id}',{id:a})}))})),describe("POST /",(()=>{it("Should post data",(async()=>{const e={__cls:class{constructor(){this.n=1}}.toString()}.toString();const a={data:e};const n=await J("/v1/store",a,k,Y(te));s.expect(n.status).eq(201);const o=t.Bitcoin.crypto.Hash.sha256(Buffer.from(e)).toString("hex");s.expect(n.data._url).eq(`${k.toLowerCase()}/store/${o}`);const r=await j.any('SELECT "id", "data" FROM "OffChain" WHERE id = ${id}',{id:o});s.expect(r.length).eq(1),s.expect(r[0].id).eq(o),s.expect(r[0].data.toString()).eq(e),await j.none('DELETE FROM "OffChain" WHERE "id" = ${hash}',{hash:o})}))}))}))})),exports.authenticatedDelete=async(e,t,a)=>u.default.delete(`${t}${e}`,{headers:{Authentication:a}}),exports.authenticatedGet=Q,exports.authenticatedPost=J;
