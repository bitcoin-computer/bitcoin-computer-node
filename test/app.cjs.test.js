"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t=require("elliptic");var e=require("bitcoin-computer-bitcore");var a=require("axios");var n=require("crypto");var o=require("pg-promise");var c=require("pg-monitor");var s=require("dotenv");var r=require("winston");require("bitcoind-rpc");var i=require("hash.js");function d(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}var l=d(a);var u=d(n);var p=d(o);var E=d(c);var x=d(s);var h=d(i);x.default.config();const{PORT:S=3e3,ZMQ_URL:$="tcp://litecoind:28332",CHAIN:T="LTC",NETWORK:R="regtest",BCN_ENV:N="dev",BCN_URL:f="http://127.0.0.1:3000",DEBUG_MODE:v=1,POSTGRES_USER:B="bcn",POSTGRES_PASSWORD:y="bcn",POSTGRES_DB:O="bcn",POSTGRES_HOST:b="127.0.0.1",POSTGRES_PORT:m=5432,RPC_PROTOCOL:g="http",RPC_USER:w="bcn-admin",RPC_PASSWORD:H="kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=",RPC_HOST:I="litecoind",RPC_PORT:C=19332,SERVER_VERSION:A=.1,DEFAULT_WALLET:P="defaultwallet"}=process.env;var K={PORT:S,ZMQ_URL:$,CHAIN:T,NETWORK:R,BCN_ENV:N,BCN_URL:f,DEBUG_MODE:v,POSTGRES_USER:B,POSTGRES_PASSWORD:y,POSTGRES_DB:O,POSTGRES_HOST:b,POSTGRES_PORT:m,POSTGRES_MAX_PARAM_NUM:65535,RPC_PROTOCOL:g,RPC_USER:w,RPC_PASSWORD:H,RPC_HOST:I,RPC_PORT:C,SYNC_HEIGHT:1,SYNC_INTERVAL_CHECK:3e3,SERVER_VERSION:A,DB_CONNECTION_RETRY_TIME:3e3,SIGNATURE_FRESHNESS_MINUTES:3,DEFAULT_WALLET:P};const _=r.createLogger({level:"info",format:r.format.json(),transports:[new r.transports.File({filename:"error.log",level:"error"}),new r.transports.File({filename:"combined.log"})]});_.add(new r.transports.Console({format:r.format.combine(r.format.colorize(),r.format.timestamp({format:"YYYY-MM-DD HH:mm:ss"}),r.format.printf((t=>`${t.level} ${t.message} [2m${t.timestamp}[0m`)))}));const D={error:(t,e)=>{e.cn&&_.info(`Connection to db failed: ${JSON.stringify(e.cn)} ${t}`)},noWarnings:!0};"dev"===K.BCN_ENV&&"1"===K.DEBUG_MODE&&(E.default.isAttached()?E.default.detach():(E.default.attach(D),E.default.setTheme("matrix")));const W=p.default(D)({host:K.POSTGRES_HOST,port:K.POSTGRES_PORT,database:K.POSTGRES_DB,user:K.POSTGRES_USER,password:K.POSTGRES_PASSWORD,allowExitOnIdle:!0,idleTimeoutMillis:100});const L=(t,e=Date.now(),a)=>{if(!a){const n=h.default.sha256().update(K.BCN_URL+e).digest("hex");a=t.sign(n).toDER("hex")}const n=[a,t.getPublic().encodeCompressed("hex"),e];return`Bearer ${Buffer.from(n.join(":")).toString("base64")}`};const{UN_P2SH_URL:G}=process.env;const U=(t,e)=>t.length===e.length&&t.slice().sort().every(((t,a)=>t===e.slice().sort()[a]));const M=async(t,e,a)=>l.default.get(`${e}${t}`,{headers:{Authentication:a}});const F=async(t,e,a,n)=>l.default.post(`${a}${t}`,e,{headers:{Authentication:n}});const V=new t.ec("secp256k1");const q=V.genKeyPair();const k=q.getPublic().encodeCompressed("hex");const j=V.genKeyPair().getPublic().encodeCompressed("hex");const Y=V.genKeyPair().getPublic().encodeCompressed("hex");describe("app",(()=>{describe("Smart Object API",(()=>{describe("GET /wallet/${publicKey}/non-standard-utxos",(()=>{it("Should return the non-standard unspent transaction output for a given public key",(async()=>{const t=u.default.randomBytes(32).toString("hex");const e=u.default.randomBytes(32).toString("hex");const a="b0163f919eb1391f4ba124cf2a3c3e20d84e5eb08ff75a24dd487ff7ed5120f1";const n="c3a8ee4ad98a9b9dbf4b6c3a993ec0fa5a07a5fa64824225074a42875a724473";await W.none('INSERT INTO "NonStandardTxos" ("publicKey", rev, spent, "contractName", "contractHash") VALUES (${publicKey}, ${rev}, false, ${contractName}, ${contractHash})',{publicKey:k,rev:`${t}/0`,contractName:"A",contractHash:a}),await W.none('INSERT INTO "NonStandardTxos" ("publicKey", rev, spent, "contractName", "contractHash") VALUES (${publicKey}, ${rev}, false, ${contractName2}, ${contractHash2})',{publicKey:k,rev:`${e}/2`,contractName2:"B",contractHash2:n}),await W.none('INSERT INTO "NonStandardTxos" ("publicKey", rev, spent, "contractName", "contractHash") VALUES (${publicKey}, ${rev}, true, ${contractName}, ${contractHash})',{publicKey:j,rev:`${e}/2`,contractName:"A",contractHash:a});const o=await M(`/v1/${K.CHAIN}/${K.NETWORK}/wallet/${k}/non-standard-utxos`,G,L(q));expect(o).toBeDefined(),expect(o.status).toBe(200),expect(o.data.length).toBe(2),expect(o.data[0]).toEqual({rev:expect.any(String),contractName:expect.any(String),contractHash:expect.any(String)}),expect(o.data[1]).toEqual({rev:expect.any(String),contractName:expect.any(String),contractHash:expect.any(String)}),expect(U([o.data[0].rev,o.data[1].rev],[`${t}/0`,`${e}/2`])),expect(U([o.data[0].contractName,o.data[1].contractName],["A","B"])),expect(U([o.data[0].contractHash,o.data[1].contractHash],[a,n])),await W.none('DELETE FROM "NonStandardTxos" WHERE "publicKey"=${publicKey}',{publicKey:k}),await W.none('DELETE FROM "NonStandardTxos" WHERE "publicKey"=${publicKey}',{publicKey:j})})),it("Should return blank if there are no non-standard unspent transaction outputs for the given public key in the database",(async()=>{const t=await M(`/v1/${K.CHAIN}/${K.NETWORK}/wallet/${Y}/non-standard-utxos`,G,L(q));expect(t).toBeDefined(),expect(t.status).toBe(200),expect(t.data.length).toBe(0)}))})),describe("GET /v1/${config.CHAIN}/${config.NETWORK}/non-standard-utxos",(()=>{describe("Endpoint normal behavior",(()=>{const t=u.default.randomBytes(32).toString("hex");const e=u.default.randomBytes(32).toString("hex");const a=u.default.randomBytes(32).toString("hex");const n=u.default.randomBytes(32).toString("hex");const o=u.default.randomBytes(32).toString("hex");const c=u.default.randomBytes(32).toString("hex");beforeAll((async()=>{await W.none('INSERT INTO "NonStandardTxos" ("publicKey", rev, spent, "contractName", "contractHash") VALUES (${publicKey}, ${rev}, false, ${contractName}, ${contractHash})',{publicKey:k,rev:`${t}/0`,contractName:a,contractHash:n}),await W.none('INSERT INTO "NonStandardTxos" ("publicKey", rev, spent, "contractName", "contractHash") VALUES (${publicKey}, ${rev}, false, ${contractName2}, ${contractHash2})',{publicKey:k,rev:`${e}/2`,contractName2:o,contractHash2:c}),await W.none('INSERT INTO "NonStandardTxos" ("publicKey", rev, spent, "contractName", "contractHash") VALUES (${publicKey}, ${rev}, true, ${contractName}, ${contractHash})',{publicKey:k,rev:`${t}/1`,contractName:a,contractHash:n})})),afterAll((async()=>{await W.none('DELETE FROM "NonStandardTxos" WHERE "publicKey"=${publicKey}',{publicKey:k})})),it("Should return the latest revs for a given public key",(async()=>{const t=await M(`/v1/${K.CHAIN}/${K.NETWORK}/non-standard-utxos?publicKey=${k}`,G,L(q));expect(t).toBeDefined(),expect(t.status).toBe(200),expect(t.data.length).toBe(2),expect(U[(t.data[0],t.data[1],`${e}/2`)])})),it("Should return the latest revs for a given contract name",(async()=>{const e=await M(`/v1/${K.CHAIN}/${K.NETWORK}/non-standard-utxos?contractName=${a}`,G,L(q));expect(e).toBeDefined(),expect(e.status).toBe(200),expect(e.data.length).toBe(1),expect(e.data[0]).toEqual(`${t}/0`)})),it("Should return the latest revs for a given contract hash",(async()=>{const t=await M(`/v1/${K.CHAIN}/${K.NETWORK}/non-standard-utxos?contractHash=${c}`,G,L(q));expect(t).toBeDefined(),expect(t.status).toBe(200),expect(t.data.length).toBe(1),expect(t.data[0]).toEqual(`${e}/2`)}))})),it("Should return blank if there are no latest revs for the given public key in the database",(async()=>{const t=await M(`/v1/${K.CHAIN}/${K.NETWORK}/non-standard-utxos?publicKey=${k}`,G,L(q));expect(t).toBeDefined(),expect(t.status).toBe(200),expect(t.data.length).toBe(0)})),it("Should return blank if there are no parameters set",(async()=>{const t=await M(`/v1/${K.CHAIN}/${K.NETWORK}/non-standard-utxos`,G,L(q));expect(t).toBeDefined(),expect(t.status).toBe(200),expect(t.data.length).toBe(0)})),it("Should return blank if there are latest revs for the given public key in the database",(async()=>{const t=await M(`/v1/${K.CHAIN}/${K.NETWORK}/non-standard-utxos?publicKey=${k}`,G,L(q));expect(t).toBeDefined(),expect(t.status).toBe(200),expect(t.data.length).toBe(0)}))})),describe("POST /revs",(()=>{it("Should return the latest rev for the single input object id",(async()=>{const t=u.default.randomBytes(32).toString("hex");await W.none('INSERT INTO "IdToRev" (id, rev) VALUES (${id}, ${rev})',{id:`${t}/0`,rev:`${t}/0`});const e=await F(`/v1/${K.CHAIN}/${K.NETWORK}/revs`,{ids:[`${t}/0`]},G,L(q));expect(e).toBeDefined(),expect(e.status).toBe(200),expect(e.data.length).toBe(1),expect(e.data[0]).toBe(`${t}/0`),await W.none('DELETE FROM "IdToRev" WHERE id=${id}',{id:`${t}/0`})})),it("Should return the latest revs in the same order as input object ids",(async()=>{const t=u.default.randomBytes(32).toString("hex");await W.none('INSERT INTO "IdToRev" (id, rev) VALUES (${id}, ${rev})',{id:`${t}/0`,rev:`${t}/0`}),await W.none('INSERT INTO "IdToRev" (id, rev) VALUES (${id}, ${rev})',{id:`${t}/1`,rev:`${t}/1`});const e=await F(`/v1/${K.CHAIN}/${K.NETWORK}/revs`,{ids:[`${t}/0`,`${t}/1`]},G,L(q));expect(e).toBeDefined(),expect(e.status).toBe(200),expect(e.data.length).toBe(2),expect(e.data[0]).toBe(`${t}/0`),expect(e.data[1]).toBe(`${t}/1`);const a=await F(`/v1/${K.CHAIN}/${K.NETWORK}/revs`,{ids:[`${t}/1`,`${t}/0`]},G,L(q));expect(a).toBeDefined(),expect(a.status).toBe(200),expect(a.data.length).toBe(2),expect(a.data[0]).toBe(`${t}/1`),expect(a.data[1]).toBe(`${t}/0`),await W.none('DELETE FROM "IdToRev" WHERE id=${id}',{id:`${t}/0`}),await W.none('DELETE FROM "IdToRev" WHERE id=${id}',{id:`${t}/1`})})),it("Should return null values for the given object ids that do not exist in the database",(async()=>{const t=u.default.randomBytes(32).toString("hex");await W.none('INSERT INTO "IdToRev" (id, rev) VALUES (${id}, ${rev})',{id:`${t}/0`,rev:`${t}/0`});const e=await F(`/v1/${K.CHAIN}/${K.NETWORK}/revs`,{ids:[`${t}/0`,`${t}/1`]},G,L(q));expect(e).toBeDefined(),expect(e.status).toBe(200),expect(e.data.length).toBe(2),expect(e.data[0]).toBe(`${t}/0`),expect(e.data[1]).toBe(null);const a=await F(`/v1/${K.CHAIN}/${K.NETWORK}/revs`,{ids:[`${t}/1`,`${t}/0`]},G,L(q));expect(a).toBeDefined(),expect(a.status).toBe(200),expect(a.data.length).toBe(2),expect(a.data[0]).toBe(null),expect(a.data[1]).toBe(`${t}/0`),await W.none('DELETE FROM "IdToRev" WHERE id=${id}',{id:`${t}/0`})}))})),describe("GET /wallet/:address/utxos",(()=>{const t="mzoGRNh55y9j57TPdwRGi3nt9X4CFwpqUS";it("Should return the standard unspent transaction outputs for a given address",(async()=>{const e=await M(`/v1/${K.CHAIN}/${K.NETWORK}/wallet/${t}/utxos`,G,L(q));expect(e).toBeDefined(),expect(e.status).toBe(200),e.data.length&&expect(e.data[0]).toEqual({txid:expect.any(String),vout:expect.any(Number),address:t,label:"false",scriptPubKey:"76a914d3802d2126be127424c647f2e90cfa4a15b49a2388ac",amount:expect.any(Number),confirmations:expect.any(Number),spendable:!1,solvable:!1,safe:expect.any(Boolean)})})),it("Should return [] if the given address does not exist in the database",(async()=>{const t=await M(`/v1/${K.CHAIN}/${K.NETWORK}/wallet/2N7ZZBWXQtoWPvfmmPXcJtDiGxNGLzdsY4N/utxos/`,G,L(q));expect(t).toBeDefined(),expect(t.status).toBe(200),expect(t.data.length).toBe(0)}))})),describe("GET /address/${address}/balance",(()=>{it("Should return the balance of a given address that exists in the database",(async()=>{const t=await M(`/v1/${K.CHAIN}/${K.NETWORK}/address/mzoGRNh55y9j57TPdwRGi3nt9X4CFwpqUS/balance`,G,L(q));expect(t).toBeDefined(),expect(t.status).toBe(200),expect(t.data).toEqual(expect.any(Number))})),it("Should return 0 if the given address does not exist in the database",(async()=>{const t=await M(`/v1/${K.CHAIN}/${K.NETWORK}/address/2N7ZZBWXQtoWPvfmmPXcJtDiGxNGLzdsY4N/balance/`,G,L(q));expect(t).toBeDefined(),expect(t.status).toBe(200),expect(t.data).toBe(0)}))})),describe("Transaction proxy endpoint",(()=>{let t="";let e="";let a="";let n="";beforeEach((async()=>{a=u.default.randomBytes(32).toString("hex"),n=u.default.randomBytes(32).toString("hex"),t=u.default.randomBytes(32).toString("hex"),e=u.default.randomBytes(32).toString("hex"),await W.none('INSERT INTO "Transactions"(id, tx) VALUES (${id}, ${tx})',{id:a,tx:t}),await W.none('INSERT INTO "Transactions"(id, tx) VALUES (${id}, ${tx})',{id:n,tx:e})})),afterEach((async()=>{await W.none('DELETE FROM "Transactions" WHERE id=${id}',{id:a}),await W.none('DELETE FROM "Transactions" WHERE id=${id}',{id:n})})),it("Should return a transaction from the database",(async()=>{const e=await M(`/v1/${K.CHAIN}/${K.NETWORK}/tx/${a}`,G,L(q));expect(e.status).toBe(200),expect(e.data).toBe(t),await W.none('DELETE FROM "Transactions" WHERE id=${id}',{id:a})}),2e4),it("Should throw an error if chain or network as not set correctly",(async()=>{try{await M(`/v1/foo/mainnet/tx/${a}`,G,L(q)),expect(0).toBe(1)}catch(t){expect(t.response.status).toBe(404),expect(t.message).toBe("Request failed with status code 404")}})),it("Should return fail if the transaction id does not exist",(async()=>{let t;try{t=await M(`/v1/${K.CHAIN}/${K.NETWORK}/tx/id-that-never-exists`,G,L(q))}catch(e){t=e.response,expect(t.status).toBe(404),expect(t.data.error).toBe("Not found")}}),2e4),it("Should fetch and store a transaction",(async()=>{const e=await M(`/v1/${K.CHAIN}/${K.NETWORK}/tx/${a}`,G,L(q));expect(e.status).toBe(200),expect(e.data).toBe(t),await new Promise((t=>{setTimeout(t,500)}));const n=await W.any('SELECT tx FROM "Transactions" WHERE id = ${id}',{id:a});expect(n.length).toBe(1),expect(n[0].tx.toString()).toBe(t)})),it("Should fetch and store transactions in bulk",(async()=>{const o=await F(`/v1/${K.CHAIN}/${K.NETWORK}/tx/bulk`,{txIds:[a,n]},G,L(q));expect(o.status).toBe(200),expect(o.data.length).toBe(2),expect(o.data[0]).toBe(t),expect(o.data[1]).toBe(e),await new Promise((t=>{setTimeout(t,500)}));let c=await W.any('SELECT tx FROM "Transactions" WHERE id = ${id}',{id:a});expect(c.length).toBe(1),expect(c[0].tx.toString()).toBe(t),c=await W.any('SELECT tx FROM "Transactions" WHERE id = ${id}',{id:n}),expect(c.length).toBe(1),expect(c[0].tx.toString()).toBe(e)}))}))})),describe("Off Chain Store API",(()=>{describe("GET /:id",(()=>{it("Should return data",(async()=>{const t=Math.random().toString();const a=e.Bitcoin.crypto.Hash.sha256(Buffer.from(t)).toString("hex");await W.none('INSERT INTO "OffChainStore"("id", "data") VALUES(${id}, ${data})',{data:t,id:a});const n=await M(`/v1/store/${a}`,G,L(q));expect(n.status).toBe(200),expect(n.data).toEqual(t),await W.none('DELETE FROM "OffChainStore" WHERE "id" = ${id}',{id:a})}))})),describe("POST /",(()=>{it("Should post data",(async()=>{const t={__cls:class{constructor(){this.n=1}}.toString()}.toString();const a={data:t};const n=await F("/v1/store",a,G,L(q));expect(n.status).toBe(201);const o=e.Bitcoin.crypto.Hash.sha256(Buffer.from(t)).toString("hex");expect(n.data._url).toBe(`${G.toLowerCase()}/store/${o}`);const c=await W.any('SELECT "id", "data" FROM "OffChainStore" WHERE id = ${id}',{id:o});expect(c.length).toBe(1),expect(c[0].id).toBe(o),expect(c[0].data.toString()).toBe(t),await W.none('DELETE FROM "OffChainStore" WHERE "id" = ${hash}',{hash:o})}))}))}))})),exports.authenticatedDelete=async(t,e,a)=>l.default.delete(`${e}${t}`,{headers:{Authentication:a}}),exports.authenticatedGet=M,exports.authenticatedPost=F;
