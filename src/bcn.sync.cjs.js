"use strict";var t=require("bitcoind-rpc");var e=require("util");var n=require("bitcoin-computer-lib");var a=require("dotenv");var r=require("winston");var s=require("bitcoin-computer-bitcore");var o=require("pg-promise");var i=require("pg-monitor");var c=require("hash.js");var d=require("crypto");function l(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}var S=l(t);var u=l(e);var y=l(a);var R=l(o);var p=l(i);var E=l(c);var T=l(d);y.default.config();const{PORT:f=3e3,ZMQ_URL:g="tcp://litecoind:28332",CHAIN:h="LTC",NETWORK:v="regtest",BCN_ENV:N="dev",BCN_URL:O="http://127.0.0.1:3000",DEBUG_MODE:m=1,POSTGRES_USER:P="bcn",POSTGRES_PASSWORD:x="bcn",POSTGRES_DB:$="bcn",POSTGRES_HOST:_="127.0.0.1",POSTGRES_PORT:w=5432,RPC_PROTOCOL:B="http",RPC_USER:H="bcn-admin",RPC_PASSWORD:C="kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=",RPC_HOST:I="litecoind",RPC_PORT:b=19332,SERVER_VERSION:A=.1,DEFAULT_WALLET:U="defaultwallet"}=process.env;var M={PORT:f,ZMQ_URL:g,CHAIN:h,NETWORK:v,BCN_ENV:N,BCN_URL:O,DEBUG_MODE:m,POSTGRES_USER:P,POSTGRES_PASSWORD:x,POSTGRES_DB:$,POSTGRES_HOST:_,POSTGRES_PORT:w,POSTGRES_MAX_PARAM_NUM:1e4,RPC_PROTOCOL:B,RPC_USER:H,RPC_PASSWORD:C,RPC_HOST:I,RPC_PORT:b,SYNC_HEIGHT:1,SYNC_INTERVAL_CHECK:3e3,SERVER_VERSION:A,DB_CONNECTION_RETRY_TIME:3e3,SIGNATURE_FRESHNESS_MINUTES:3,DEFAULT_WALLET:U};const L=r.createLogger({level:"info",format:r.format.json(),transports:[new r.transports.File({filename:"error.log",level:"error"}),new r.transports.File({filename:"combined.log"})]});L.add(new r.transports.Console({format:r.format.combine(r.format.colorize(),r.format.timestamp({format:"YYYY-MM-DD HH:mm:ss"}),r.format.printf((t=>`${t.level} ${t.message} [2m${t.timestamp}[0m`)))}));const{PublicKey:D}=s.Bitcoin;const G=()=>{const t={protocol:M.RPC_PROTOCOL,user:M.RPC_USER,pass:M.RPC_PASSWORD,host:M.RPC_HOST,port:M.RPC_PORT};return new S.default(t)};const F=t=>new Promise((e=>{setTimeout(e,t)}));const W=t=>t.isPublicKeyOut()?new D(t.getPublicKey()).toAddress(M.NETWORK).toString("legacy"):t.toAddress(M.NETWORK).toString("legacy");const K={error:(t,e)=>{e.cn&&L.info(`Connection to db failed: ${JSON.stringify(e.cn)} ${t}`)},noWarnings:!0};"dev"===M.BCN_ENV&&M.DEBUG_MODE>0&&(p.default.isAttached()?p.default.detach():(p.default.attach(K),p.default.setTheme("matrix")));const k=R.default(K)({host:M.POSTGRES_HOST,port:M.POSTGRES_PORT,database:M.POSTGRES_DB,user:M.POSTGRES_USER,password:M.POSTGRES_PASSWORD,allowExitOnIdle:!0,idleTimeoutMillis:100});class q{static async getProgress(){return k.one('SELECT "syncedHeight", "bitcoindSyncedHeight", "bitcoindSyncedProgress" FROM "SyncProgress"')}static async saveProgress(t,e,n){const a=new o.PreparedStatement({name:"SyncProgress.save",text:'UPDATE "SyncProgress" SET "syncedHeight" = $1, "bitcoindSyncedHeight" = $2, "bitcoindSyncedProgress" = $3',values:[t,e,n]});await k.any(a)}}class V{static async getProgress(){return q.getProgress()}static async saveProgres(t,e,n){await q.saveProgress(t,e,n)}}var Y=async()=>V.getProgress();class j{static async countByRev(t){if(!t.length)return 0;let e=t.map((t=>`('${t.prevTxId.toString("hex")}/${t.outputIndex}')`)).join(",");e=`(  ${e} )`;const n=new o.PreparedStatement({name:`NonStandardTxos.countByRev$${T.default.randomBytes(10).toString("hex")}`,text:`SELECT count("rev") FROM "NonStandardTxos" WHERE "rev" IN ${e}`});const a=await k.oneOrNone(n);return parseInt(null==a?void 0:a.count,10)||0}static async findNonStandardTxoByRev(t){const e=new o.PreparedStatement({name:"NonStandardTxo.findNonStandardTxoByRev",text:'SELECT "rev", "contractName", "contractHash" FROM "NonStandardTxos" WHERE "rev" = $1',values:[t]});return k.oneOrNone(e)}static async findRevById(t){const e=new o.PreparedStatement({name:"NonStandardTxo.findRevById",text:'SELECT "rev" FROM "NonStandardTxos" WHERE "id" = $1',values:[t]});return k.any(e)}static async findManyNonStandardUtxosRevsById(t){const e=new o.PreparedStatement({name:"NonStandardTxo.findManyRevsById",text:'SELECT "rev" FROM "NonStandardTxos" WHERE "id" LIKE ANY($1)',values:[[t]]});return k.any(e)}static async findManyNonStandardUtxos(t){const{publicKey:e,contractName:n,contractHash:a}=t;if(void 0===e&&void 0===n&&void 0===a)return[];let r='SELECT "rev", "contractName", "contractHash" FROM "NonStandardTxos"';let s=' WHERE "rev" IS NOT NULL';let i="findManyNonStandardUtxos";const c=[];e&&(i+=(0===c.length?"By":"And")+"PublicKeys",c.push(e),s+=' AND $1 = ANY ("publicKeys")'),n&&(i+=(0===c.length?"By":"And")+"ContractName",c.push(n),s+=` AND "contractName" = $${c.length}`),a&&(i+=(0===c.length?"By":"And")+"ContractHash",c.push(a),s+=` AND "contractHash" = $${c.length}`),r+=s;const d=new o.PreparedStatement({name:i,text:r,values:c});return k.any(d)}static async saveNonStandardUtxo(t,e,n,a,r){const s=new o.PreparedStatement({name:"NonStandardTxo.saveNonStandardUtxo",text:'INSERT INTO "NonStandardTxos"("id", "rev", "publicKeys", "contractName", "contractHash") VALUES ($1, $2, $3, $4, $5)',values:[t,e,n,a,r]});await k.none(s)}static async updateNonStandardTxo(t,e,n){const a=new o.PreparedStatement({name:"NonStandardTxo.updateNonStandardTxo",text:'UPDATE "NonStandardTxos" SET "rev" = $1, "publicKeys" = $3 WHERE "rev" = $2',values:[t,e,n]});await k.none(a)}}class z{static async getNonStandardTxoByRevId(t){return j.findNonStandardTxoByRev(t)}static async queryNonStandardUtxos(t){return j.findManyNonStandardUtxos(t)}static async getRev(t){return j.findRevById(t)}static async getRevs(t){return j.findManyNonStandardUtxosRevsById(t)}static async addNonStandardUtxo(t,e,n,a,r){return j.saveNonStandardUtxo(t,e,n,a,r)}static async updateNonStandardTxo(t,e,n){return j.updateNonStandardTxo(t,e,n)}static async getCount(t){return j.countByRev(t)}}function J(t){if(!/^[0-9A-Fa-f]{64}\/\d+$/.test(t))throw new Error(`Invalid outId: ${t}`)}const X=(t,e)=>Object.assign(new Array(e).fill(null),t);var Z=async(t,e,n)=>{if(Array.isArray(e)&&Array.isArray(n)&&t){const r=Math.max(e.length,n.length);const s=X(e,r);const o=X(n,r);const i=(a=o,s.map(((t,e)=>[t,a[e]])));if(t.length!==n.length)return;await Promise.all(i.map((async([e,n],a)=>{const{__cls:r="",_owners:s=[]}=t[a];const o=!!e&&!!n;if(null===e&&n){const t=(t=>{if(!t.length)return"";const e=t.startsWith("export ")?t.slice(7):t;return(e.startsWith("default ")?e.slice(8):e).split(" ")[1]})(r);const e=E.default.sha256().update(r).digest("hex");J(n),await z.addNonStandardUtxo(n,n,s,t,e)}else o&&(J(e),await z.updateNonStandardTxo(n,e,s))})))}var a};var Q=async t=>{for(let e=0;e<t.length;e+=1)try{const{inRevs:n,outRevs:a,outData:r,txId:s}=t[e];if(!(null==r?void 0:r.length))return;await Z(r,n,a),L.info(`Synced to "${s}"`)}catch(n){L.error(`Failed processing ${JSON.stringify(t[e])} because of ${n.message}`)}};var tt=async(t,e,n)=>{await V.saveProgres(t,e,n)};class et{static async countByTxIdVout(t){if(!t.length)return 0;let e=t.map((t=>`('${t.prevTxId.toString("hex")}/${t.outputIndex}')`)).join(",");e=`( ${e} )`;const n=new o.PreparedStatement({name:`StandardUtxos.countByTxIdVout$${T.default.randomBytes(10).toString("hex")}`,text:`SELECT count("rev") FROM "StandardUtxos" WHERE "rev" IN ${e}`});const a=await k.oneOrNone(n);return parseInt(null==a?void 0:a.count,10)||0}static async findManyByAddress(t){const e=new o.PreparedStatement({name:"StandardUtxos.findManyByAddress",text:'SELECT "address", ("satoshis"/100000000.0) AS "amount", "satoshis", "scriptPubKey", "rev" FROM "StandardUtxos" WHERE "address" = $1',values:[t]});return(await k.any(e)).map((t=>({...t,amount:parseFloat(t.amount),satoshis:parseInt(t.satoshis,10)})))}static async getBalance(t){const e=new o.PreparedStatement({name:"StandardUtxos.getBalance",text:'SELECT SUM("satoshis") FROM "StandardUtxos" WHERE "address" = $1',values:[t]});const n=await k.oneOrNone(e);return parseInt(null==n?void 0:n.sum,10)||0}static async saveBatch(t){const e=t.flatMap((t=>[`${t.txId}/${t.outputIndex}`,t.address.toString("legacy"),t.satoshis,t.script.toHex()]));for(;e.length;){const t=e.splice(0,M.POSTGRES_MAX_PARAM_NUM);const n=[];for(let e=1;e<=t.length;e+=4)n.push(`($${e}, $${e+1}, $${e+2}, $${e+3})`);const a=n.join(",");const r=new o.PreparedStatement({name:`StandardUtxos.saveBatch$${T.default.randomBytes(10).toString("hex")}`,text:`INSERT INTO "StandardUtxos"("rev", "address", "satoshis", "scriptPubKey") VALUES ${a}  ON CONFLICT DO NOTHING`,values:t});await k.none(r)}}static async deleteSpentBatch(t){const e=t.flatMap((t=>[`${t.prevTxId.toString("hex")}/${t.outputIndex}`]));const n=M.POSTGRES_MAX_PARAM_NUM;for(;e.length;){const t=e.splice(0,n);const a=[];for(let e=1;e<=t.length;e+=1)a.push(`("rev" = $${e})`);const r=a.join(" OR ");const s=new o.PreparedStatement({name:`StandardUtxos.deleteSpentBatch${T.default.randomBytes(10).toString("hex")}`,text:`DELETE FROM "StandardUtxos" WHERE ${r}`,values:t});await k.none(s)}}}const{Transaction:nt}=s.Bitcoin;const{Input:at}=nt;const{Script:rt,Transaction:st}=s.Bitcoin;const{UnspentOutput:ot}=st;var it=async t=>{const e=t.flatMap((({tx:t})=>t.inputs));const n=t.flatMap((({tx:t})=>t.outputs.map(((e,n)=>{const a=e;return a.txId=t.id,a.n=n,a}))));await(async t=>{try{const e=t.filter((t=>{try{const e=rt.fromBuffer(t._scriptBuffer);return e.isPublicKeyHashOut()||e.isPublicKeyOut()}catch(t){return!1}})).map((t=>{const e=rt.fromBuffer(t._scriptBuffer);return new ot({address:W(e),txId:t.txId,outputIndex:t.n,scriptPubKey:e.toHex(),amount:t._satoshis/1e8,satoshis:Math.round(t._satoshis)})}));return et.saveBatch(e)}catch(t){if(!t.message.includes("duplicate key value violates unique constraint"))throw t;return Promise.resolve(void 0)}})(n),await(async t=>{const e=t.map((t=>at.fromObject({...t,script:t._scriptBuffer}))).filter((t=>!t.isNull()));return et.deleteSpentBatch(e)})(e)};const{CHAIN:ct,NETWORK:dt,BCN_URL:lt}=M;const St=new n.Computer({chain:ct,network:dt,url:lt});const ut=async(t,e,n)=>{try{const a=G();const r=u.default.promisify(S.default.prototype.getBlockHash.bind(a));const s=u.default.promisify(S.default.prototype.getBlock.bind(a));let{result:o}=await r(t);for(;t<=e;){const{result:a}=await s(o,2);const{tx:r,nextblockhash:i}=a;L.info(`Backfilling progress ${t}/${e} blocks [${(t/e*100).toFixed(4)}% (bitcoind progress: ${(100*n).toFixed(4)}%)]\n        Backfilling ${r.length} transactions...`);const c=await Promise.all(r.map((t=>St.db.fromTxHex(t.hex))));await Q(c),await it(c),await tt(t,e,n),o=i,t+=1}}catch(t){L.error(`Error ${t.message}. Sync process.`)}};!function(){try{L.info(`Synchronizing to CHAIN: ${M.CHAIN} NETWORK: ${M.NETWORK}`),L.info(`Server url: ${M.BCN_URL}`),"regtest"!==M.NETWORK?(async()=>{let t=!1;do{try{await k.connect(),t=!0}catch(t){L.info(`Re-trying db connection: HOST=${M.POSTGRES_HOST}, PORT=${M.POSTGRES_PORT}, DATABASE=${M.POSTGRES_DB} USER=${M.POSTGRES_USER}`)}await F(M.DB_CONNECTION_RETRY_TIME)}while(!t)})().then((async()=>{await(async()=>{try{const t=G();const e=u.default.promisify(S.default.prototype.getBlockchainInfo.bind(t));let n={};let a=!1;do{try{n=await e(),L.info(`Trying to get blockchain Info bitcoindSyncedProgress ${(100*parseFloat(n.result.verificationprogress)).toFixed(4)}% Blocks: ${n.result.blocks}`),parseFloat(n.result.verificationprogress)>1e-6&&(a=!0)}catch(t){L.info(`Sync. Trying to get blockchain info: ${t.message}`),await F(5e3)}}while(!a);let r=await Y();await tt(r.syncedHeight,n.result.blocks,n.result.verificationprogress);let s=Math.max(M.SYNC_HEIGHT,r.syncedHeight+1);for(L.info(`Starting synch process bitcoind.progress: ${(100*parseFloat(n.result.verificationprogress)).toFixed(4)}% bitcoindSyncedHeight: ${n.result.blocks}\n      syncedHeight: ${r.syncedHeight}\n      currentBlockHeight: ${s}`);parseFloat(n.result.verificationprogress)<.999||s<=r.bitcoindSyncedHeight;)await ut(s,r.bitcoindSyncedHeight,n.result.verificationprogress),n=await e(),r=await Y(),r.bitcoindSyncedHeight=n.result.blocks,await tt(r.syncedHeight,r.bitcoindSyncedHeight,n.result.verificationprogress),L.info(`Bitcoind progress: ${(100*parseFloat(n.result.verificationprogress)).toFixed(4)}%`),s=r.syncedHeight+1}catch(t){L.error(`Error ${t.message}. Sync process.`)}})()})):L.info("Synchronization to network 'regtest' avoided.")}catch(t){L.error(`Error in sync: ${t.message}`)}}();
