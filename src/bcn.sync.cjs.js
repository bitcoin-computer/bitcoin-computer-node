"use strict";var t=require("bitcoind-rpc");var e=require("util");var a=require("dotenv");var n=require("winston");require("bitcoin-computer-bitcore");var r=require("pg-promise");var s=require("pg-monitor");var o=require("bitcoin-computer-lib");var i=require("hash.js");function c(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}var d=c(t);var l=c(e);var S=c(a);var u=c(r);var y=c(s);var R=c(i);S.default.config();const{PORT:T=3e3,ZMQ_URL:E="tcp://litecoind:28332",CHAIN:v="LTC",NETWORK:p="regtest",BCN_ENV:g="dev",BCN_URL:f="http://127.0.0.1:3000",DEBUG_MODE:O=1,POSTGRES_USER:P="bcn",POSTGRES_PASSWORD:m="bcn",POSTGRES_DB:N="bcn",POSTGRES_HOST:h="127.0.0.1",POSTGRES_PORT:w=5432,RPC_PROTOCOL:_="http",RPC_USER:$="bcn-admin",RPC_PASSWORD:C="kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=",RPC_HOST:H="litecoind",RPC_PORT:I=19332,SERVER_VERSION:x=.1,DEFAULT_WALLET:b="defaultwallet"}=process.env;var A={PORT:T,ZMQ_URL:E,CHAIN:v,NETWORK:p,BCN_ENV:g,BCN_URL:f,DEBUG_MODE:O,POSTGRES_USER:P,POSTGRES_PASSWORD:m,POSTGRES_DB:N,POSTGRES_HOST:h,POSTGRES_PORT:w,POSTGRES_MAX_PARAM_NUM:65535,RPC_PROTOCOL:_,RPC_USER:$,RPC_PASSWORD:C,RPC_HOST:H,RPC_PORT:I,SYNC_HEIGHT:1,SYNC_INTERVAL_CHECK:3e3,SERVER_VERSION:x,DB_CONNECTION_RETRY_TIME:3e3,SIGNATURE_FRESHNESS_MINUTES:3,DEFAULT_WALLET:b};const B=n.createLogger({level:"info",format:n.format.json(),transports:[new n.transports.File({filename:"error.log",level:"error"}),new n.transports.File({filename:"combined.log"})]});B.add(new n.transports.Console({format:n.format.combine(n.format.colorize(),n.format.timestamp({format:"YYYY-MM-DD HH:mm:ss"}),n.format.printf((t=>`${t.level} ${t.message} [2m${t.timestamp}[0m`)))}));const U=()=>{const t={protocol:A.RPC_PROTOCOL,user:A.RPC_USER,pass:A.RPC_PASSWORD,host:A.RPC_HOST,port:A.RPC_PORT};return new d.default(t)};const D=t=>new Promise((e=>{setTimeout(e,t)}));const L={error:(t,e)=>{e.cn&&B.info(`Connection to db failed: ${JSON.stringify(e.cn)} ${t}`)},noWarnings:!0};"dev"===A.BCN_ENV&&"1"===A.DEBUG_MODE&&(y.default.isAttached()?y.default.detach():(y.default.attach(L),y.default.setTheme("matrix")));const M=u.default(L)({host:A.POSTGRES_HOST,port:A.POSTGRES_PORT,database:A.POSTGRES_DB,user:A.POSTGRES_USER,password:A.POSTGRES_PASSWORD,allowExitOnIdle:!0,idleTimeoutMillis:100});class G{static async getProgress(){return M.one('SELECT "syncedHeight", "bitcoindSyncedHeight", "bitcoindSyncedProgress" FROM "SyncProgress"')}static async saveProgress(t,e,a){const n=new r.PreparedStatement({name:"SyncProgress.save",text:'UPDATE "SyncProgress" SET "syncedHeight" = $1, "bitcoindSyncedHeight" = $2, "bitcoindSyncedProgress" = $3',values:[t,e,a]});await M.any(n)}}class F{static async getProgress(){return G.getProgress()}static async saveProgres(t,e,a){await G.saveProgress(t,e,a)}}var W=async()=>F.getProgress();class k{static async findById(t){const e=new r.PreparedStatement({name:"Transaction.findById",text:'SELECT tx FROM "Transactions" WHERE id = $1',values:[t]});const a=await M.oneOrNone(e);return null===a?null:a.tx.toString()}static async save(t,e){const a=new r.PreparedStatement({name:"Transaction.save",text:'INSERT INTO "Transactions"(id, tx) VALUES ($1, $2) ON CONFLICT DO NOTHING',values:[t,e]});await M.none(a)}}var K=async(t,e)=>{await class{static async getTransaction(t){return k.findById(t)}static async getBulkTransactions(t,e,a){return Promise.all(a.map((t=>k.findById(t))))}static async addTransaction(t,e){await k.save(t,e)}static async broadcastRawTransaction(t){const e=U();const a=l.default.promisify(d.default.prototype.sendRawTransaction.bind(e));const{result:n}=await a(t);return await this.addTransaction(n,t),n}}.addTransaction(t,e)};class V{static async findById(t){const e=new r.PreparedStatement({name:"IdToRev.findById",text:'SELECT "rev" FROM "IdToRev" WHERE id = $1',values:[t]});return M.any(e)}static async findManyById(t){const e=new r.PreparedStatement({name:"IdToRev.findManyById",text:'SELECT "id", "rev" FROM "IdToRev" WHERE "id" LIKE ANY($1)',values:[[t]]});return M.any(e)}static async save(t,e){const a=new r.PreparedStatement({name:"IdToRev.save",text:'INSERT INTO "IdToRev" (id, rev) VALUES ($1, $2)',values:[t,e]});await M.any(a)}static async update(t,e){const a=new r.PreparedStatement({name:"IdToRev.update",text:'UPDATE "IdToRev" SET rev = $1 WHERE rev = $2',values:[t,e]});await M.any(a)}}class q{static async getRev(t){return V.findById(t)}static async getRevs(t){const e=await V.findManyById(t);const a=new Map(e.map((t=>[t.id,t.rev])));return t.map((t=>a.has(t)?a.get(t):null))}static async addRev(t,e){return V.save(t,e)}static async updateRev(t,e){return V.update(t,e)}}class Y{static async findByRevId(t){const e=new r.PreparedStatement({name:"NonStandardTxo.findByRevId",text:'SELECT "rev", "contractName", "contractHash" FROM "NonStandardTxos" WHERE "rev" = $1',values:[t]});return M.oneOrNone(e)}static async findManyNonStandardUtxos(t){const{publicKey:e,contractName:a,contractHash:n}=t;if(void 0===e&&void 0===a&&void 0===n)return[];let s='SELECT "rev", "contractName", "contractHash" FROM "NonStandardTxos"';let o=' WHERE "spent" = false';let i="findManyNonStandardUtxos";const c=[];e&&(i+=(0===c.length?"By":"And")+"PublicKey",c.push(e),o+=' AND "publicKey" = $1'),a&&(i+=(0===c.length?"By":"And")+"ContractName",c.push(a),o+=` AND "contractName" = $${c.length}`),n&&(i+=(0===c.length?"By":"And")+"ContractHash",c.push(n),o+=` AND "contractHash" = $${c.length}`),s+=o;const d=new r.PreparedStatement({name:i,text:s,values:c});return M.any(d)}static async saveNonStandardUtxo(t,e,a,n){const s=new r.PreparedStatement({name:"NonStandardTxo.saveNonStandardUtxo",text:'INSERT INTO "NonStandardTxos"("publicKey", "rev", "spent", "contractName", "contractHash") VALUES ($1, $2, false, $3, $4)',values:[e,t,a,n]});await M.none(s)}static async updateSpent(t){const e=new r.PreparedStatement({name:"NonStandardTxo.updateSpent",text:'UPDATE "NonStandardTxos" SET "spent" = true WHERE "rev" = $1',values:[t]});await M.none(e)}}class j{static async getNonStandardTxoByRevId(t){return Y.findByRevId(t)}static async queryNonStandardUtxos(t){return Y.findManyNonStandardUtxos(t)}static async addNonStandardUtxo(t,e,a,n){return Y.saveNonStandardUtxo(t,e,a,n)}static async updateSpent(t){return Y.updateSpent(t)}}function z(t){return function(t){if(!/^[0-9A-Fa-f]{64}\/\d+$/.test(t))throw new Error(`Invalid outId: ${t}`)}(t),{rev:t}}const{CHAIN:J,NETWORK:Z,BCN_URL:Q}=A;const X=new o.Computer({chain:J,network:Z,url:Q});var tt=async t=>{let e;let a;let n;let r;try{({inRevs:e,outRevs:a,outData:n,txId:r}=await X.db.fromTxHex(t))}catch(e){"dev"===A.BCN_ENV&&B.error(`Error parsing transaction "${t}": ${e}`)}if(n.length)try{await(async(t,e,a)=>{try{if(Array.isArray(e)&&Array.isArray(a)&&t){const r=(t,e)=>Object.assign(new Array(e).fill(null),t);const s=Math.max(e.length,a.length);const o=r(e,s);const i=r(a,s);const c=a.length;const d=(n=i,o.map(((t,e)=>[t,n[e]])));const l=JSON.parse(t);if(l.length!==a.length)return;await Promise.all(d.map((async([t,e],a)=>{const n=l[a];const r=!!t&&!!e;const s=c>0;let o="";let i="";if(null===t&&e){const{__cls:t}=n;t&&(o=(t=>{const e=t.startsWith("export ")?t.slice(7):t;return(e.startsWith("default ")?e.slice(8):e).split(" ")[1]})(t),i=R.default.sha256().update(t).digest("hex")),await q.addRev(e,e)}else if(r){const a=z(t);const n=await j.getNonStandardTxoByRevId(a.rev);o=null==n?void 0:n.contractName,i=null==n?void 0:n.contractHash,await q.updateRev(e,t),await j.updateSpent(a.rev)}if(s){const t=z(e);await Promise.all(n._owners.map((e=>j.addNonStandardUtxo(t.rev,e,o,i))))}})))}}catch(t){if(!t.message.includes("duplicate key value violates unique constraint"))throw t}var n})(JSON.stringify(n),e,a),await K(r,t),B.info(`Synced to "${r}"`)}catch(e){B.error(`Error syncing to "${t}": ${e}`)}};var et=async(t,e,a)=>{await F.saveProgres(t,e,a)};const at=async(t,e,a)=>{try{const n=U();const r=l.default.promisify(d.default.prototype.getBlockHash.bind(n));const s=l.default.promisify(d.default.prototype.getBlock.bind(n));let{result:o}=await r(t);for(;t<=e;){const{result:n}=await s(o,2);B.info(`Backfilling progress ${t}/${e} blocks [${(t/e*100).toFixed(4)}% (bitcoind progress: ${(100*a).toFixed(4)}%)]\n        Backfilling ${n.tx.length} transactions...`);for(let t=0;t<n.tx.length;t+=1)try{await tt(n.tx[t].hex)}catch(e){B.error(`Failed processing ${n.tx[t]} because of ${e.message}`)}await et(t,e,a),o=n.nextblockhash,t+=1}}catch(t){B.error(`Error ${t.message}. Sync process.`)}};!function(){try{B.info(`Synchronizing to CHAIN: ${A.CHAIN} NETWORK: ${A.NETWORK}`),B.info(`Server url: ${A.BCN_URL}`),"regtest"!==A.NETWORK?(async()=>{let t=!1;do{try{await M.connect(),t=!0}catch(t){B.info(`Re-trying db connection: HOST=${A.POSTGRES_HOST}, PORT=${A.POSTGRES_PORT}, DATABASE=${A.POSTGRES_DB} USER=${A.POSTGRES_USER}`)}await D(A.DB_CONNECTION_RETRY_TIME)}while(!t)})().then((async()=>{await(async()=>{try{const t=U();const e=l.default.promisify(d.default.prototype.getBlockchainInfo.bind(t));let a={};let n=!1;do{try{a=await e(),B.info(`Trying to get blockchain Info bitcoindSyncedProgress ${(100*parseFloat(a.result.verificationprogress)).toFixed(4)}% Blocks: ${a.result.blocks}`),parseFloat(a.result.verificationprogress)>1e-6&&(n=!0)}catch(t){B.info(`Sync. Trying to get blockchain info: ${t.message}`),await D(5e3)}}while(!n);let r=await W();await et(r.syncedHeight,a.result.blocks,a.result.verificationprogress);let s=Math.max(A.SYNC_HEIGHT,r.syncedHeight+1);for(B.info(`Starting synch process bitcoind.progress: ${(100*parseFloat(a.result.verificationprogress)).toFixed(4)}% bitcoindSyncedHeight: ${a.result.blocks}\n      syncedHeight: ${r.syncedHeight}\n      currentBlockHeight: ${s}`);parseFloat(a.result.verificationprogress)<.999||s<=r.bitcoindSyncedHeight;)await at(s,r.bitcoindSyncedHeight,a.result.verificationprogress),a=await e(),r=await W(),r.bitcoindSyncedHeight=a.result.blocks,await et(r.syncedHeight,r.bitcoindSyncedHeight,a.result.verificationprogress),B.info(`Bitcoind progress: ${(100*parseFloat(a.result.verificationprogress)).toFixed(4)}%`),s=r.syncedHeight+1}catch(t){B.error(`Error ${t.message}. Sync process.`)}})()})):B.info("Synchronization to network 'regtest' avoided.")}catch(t){B.error(`Error in sync: ${t.message}`)}}();
