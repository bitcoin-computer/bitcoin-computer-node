"use strict";var t=require("bitcoin-computer-lib");var e=require("exponential-backoff");var a=require("dotenv");var s=require("winston");var n=require("bitcoind-rpc");var r=require("util");var o=require("pg-promise");var i=require("pg-monitor");var c=require("bitcoin-computer-bitcore");function d(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}var l=d(a);var p=d(n);var u=d(r);var S=d(o);var y=d(i);l.default.config();const{PORT:f="3000",ZMQ_URL:g="tcp://litecoind:28332",CHAIN:E="LTC",NETWORK:R="regtest",BCN_ENV:m="dev",BCN_URL:h="http://127.0.0.1:3000",DEBUG_MODE:T="1",POSTGRES_USER:O="bcn",POSTGRES_PASSWORD:v="bcn",POSTGRES_DB:P="bcn",POSTGRES_HOST:w="127.0.0.1",POSTGRES_PORT:_="5432",RPC_PROTOCOL:b="http",RPC_USER:H="bcn-admin",RPC_PASSWORD:N="kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=",RPC_HOST:$="litecoind",RPC_PORT:C="19332",SERVER_VERSION:A="0.1",DEFAULT_WALLET:I="defaultwallet"}=process.env;const B=process.env.ALLOWED_RPC_METHODS?process.env.ALLOWED_RPC_METHODS.split(",").map((t=>new RegExp(t))):[];var x={PORT:parseInt(f,10),ZMQ_URL:g,CHAIN:E,NETWORK:R,BCN_ENV:m,BCN_URL:h,DEBUG_MODE:parseInt(T,10),POSTGRES_USER:O,POSTGRES_PASSWORD:v,POSTGRES_DB:P,POSTGRES_HOST:w,POSTGRES_PORT:parseInt(_,10),POSTGRES_MAX_PARAM_NUM:1e4,RPC_PROTOCOL:b,RPC_USER:H,RPC_PASSWORD:N,RPC_HOST:$,RPC_PORT:parseInt(C,10),SYNC_HEIGHT:1,SYNC_INTERVAL_CHECK:3e3,SERVER_VERSION:A,DB_CONNECTION_RETRY_TIME:500,SIGNATURE_FRESHNESS_MINUTES:3,DEFAULT_WALLET:I,ALLOWED_RPC_METHODS:B};const{DEBUG_MODE:M}=x;const D=s.createLogger({level:["error","warn","info","http","verbose","debug","silly"][M],format:s.format.json(),transports:[new s.transports.Console({format:s.format.combine(s.format.colorize(),s.format.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),s.format.printf((t=>`[2m${t.timestamp}[0m ${t.level} ${t.message}`)))})],exceptionHandlers:[new s.transports.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new s.transports.File({filename:"logs/rejections.log"})]});const L={maxFiles:1,maxSize:1e5};M>=0&&D.add(new s.transports.File({filename:"error.log",level:"error"})),M>=1&&D.add(new s.transports.File({filename:"logs/warn.log",level:"warn",...L})),M>=2&&D.add(new s.transports.File({filename:"logs/info.log",level:"info",...L})),M>=3&&D.add(new s.transports.File({filename:"logs/http.log",level:"http",...L})),M>=4&&D.add(new s.transports.File({filename:"logs/verbose.log",level:"verbose",...L})),M>=5&&D.add(new s.transports.File({filename:"logs/debug.log",level:"debug",...L}));const F={protocol:x.RPC_PROTOCOL,user:x.RPC_USER,pass:x.RPC_PASSWORD,host:x.RPC_HOST,port:x.RPC_PORT};const U=new p.default(F);const k={createwallet:u.default.promisify(p.default.prototype.createwallet.bind(U)),generateToAddress:u.default.promisify(p.default.prototype.generateToAddress.bind(U)),getaddressinfo:u.default.promisify(p.default.prototype.getaddressinfo.bind(U)),getBlock:u.default.promisify(p.default.prototype.getBlock.bind(U)),getBlockchainInfo:u.default.promisify(p.default.prototype.getBlockchainInfo.bind(U)),getBlockHash:u.default.promisify(p.default.prototype.getBlockHash.bind(U)),getRawTransaction:u.default.promisify(p.default.prototype.getRawTransaction.bind(U)),getTransaction:u.default.promisify(p.default.prototype.getTransaction.bind(U)),importaddress:u.default.promisify(p.default.prototype.importaddress.bind(U)),listunspent:u.default.promisify(p.default.prototype.listunspent.bind(U)),sendRawTransaction:u.default.promisify(p.default.prototype.sendRawTransaction.bind(U))};const G=(t,e)=>Object.assign(new Array(e).fill(null),t);const{POSTGRES_HOST:W,POSTGRES_PORT:K,POSTGRES_DB:q,POSTGRES_USER:Y,POSTGRES_PASSWORD:V,DB_CONNECTION_RETRY_TIME:j}=x;const z={error:(t,e)=>{if(e.cn){const{host:a,port:s,database:n,user:r,password:o}=e.cn;D.debug(`Waiting for db to start { message:${t.message} host:${a}, port:${s}, database:${n}, user:${r}, password: ${o}`)}},noWarnings:!0};"dev"===x.BCN_ENV&&x.DEBUG_MODE>0&&(y.default.isAttached()?y.default.detach():(y.default.attach(z),y.default.setTheme("matrix")));const Z=S.default(z)({host:W,port:K,database:q,user:Y,password:V,allowExitOnIdle:!0,idleTimeoutMillis:100});class Q{static async select(){return Z.one('SELECT "syncedHeight", "bitcoindSyncedHeight", "bitcoindSyncedProgress" FROM "Sync"')}static async update({syncedHeight:t,bitcoindSyncedHeight:e,bitcoindSyncedProgress:a}){const s=new o.PreparedStatement({name:`Sync.update.${Math.random()}`,text:'UPDATE "Sync" SET "syncedHeight" = $1, "bitcoindSyncedHeight" = $2, "bitcoindSyncedProgress" = $3',values:[t,e,a]});await Z.any(s)}}class X{static async select(){return Q.select()}static async update(t){await Q.update(t)}}var J=async()=>X.select();var tt=async t=>{await X.update(t)};class et{static async select(t){const e=new o.PreparedStatement({name:`Standard.select.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev" FROM "Standard" WHERE "address" = $1 AND "spent" = FALSE',values:[t]});return(await Z.any(e)).map((t=>({...t,satoshis:parseInt(t.satoshis,10)})))}static async insert(t){const e=t.flatMap((t=>[t.rev,t.address,t.satoshis,t.scriptPubKey,!1]));for(;e.length;){const t=e.splice(0,x.POSTGRES_MAX_PARAM_NUM);const a=[];for(let e=1;e<=t.length;e+=5)a.push(`($${e}, $${e+1}, $${e+2}, $${e+3}, $${e+4})`);const s=a.join(",");const n=new o.PreparedStatement({name:`Standard.insert.${Math.random()}`,text:`INSERT INTO "Standard"("rev", "address", "satoshis", "scriptPubKey", "spent") VALUES ${s}  ON CONFLICT DO NOTHING`,values:t});await Z.none(n)}}static async update(t){const e=t.flatMap((t=>[`${t.prevTxId.toString("hex")}/${t.outputIndex}`]));if(0===e.length)return[];const a=[];for(let t=1;t<=e.length;t+=1)a.push(`("rev" = $${t})`);const s=a.join(" OR ");const n=new o.PreparedStatement({name:`Standard.update.${Math.random()}`,text:`UPDATE "Standard" SET "spent" = TRUE WHERE ${s} RETURNING "rev"`,values:e});return Z.any(n)}static async getBalance(t){const e=new o.PreparedStatement({name:`Standard.getBalance.${Math.random()}`,text:'SELECT SUM("satoshis") FROM "Standard" WHERE "address" = $1 AND "spent" = FALSE',values:[t]});const a=await Z.oneOrNone(e);return parseInt(null==a?void 0:a.sum,10)||0}}const{Transaction:at}=c.Bitcoin;const{Input:st}=at;var nt=async t=>{const e=t.map((t=>st.fromObject({...t,script:t._scriptBuffer}))).filter((t=>!t.isNull()));return et.update(e)};const{Script:rt,Transaction:ot}=c.Bitcoin;var it=async(t,e)=>{const a=t.flatMap(((t,a)=>{const s=rt.fromBuffer(t._scriptBuffer);const{PUBKEYHASH_OUT:n,SCRIPTHASH_OUT:r}=rt.types;if(![n,r].includes(s.classify()))return[];const o=s.toAddress(x.NETWORK).toString("legacy");const i=s.toHex();const c=t.satoshis/1e8;const d=Math.round(t.satoshis);return[new ot.UnspentOutput({address:o,txId:e,outputIndex:a,scriptPubKey:i,amount:c,satoshis:d})]}));await class{static async select(t){return(await et.select(t)).map((t=>({...t,amount:t.satoshis/1e8})))}static async getBalance(t){return et.getBalance(t)}static async insert(t){const e=t.map((t=>({rev:`${t.txId}/${t.outputIndex}`,address:t.address.toString("legacy"),satoshis:t.satoshis,scriptPubKey:t.script.toHex(),spent:!1})));return et.insert(e)}}.insert(a)};class ct{static async query(t){const{publicKey:e,classHash:a}=t;if(void 0===e&&void 0===a)return[];let s='SELECT "rev"\n      FROM "NonStandard"\n      WHERE "spent" = FALSE';const n=[];e&&(n.push(e),s+=' AND $1 = ANY ("publicKeys")'),a&&(n.push(a),s+=` AND "classHash" = $${n.length}`);const r=new o.PreparedStatement({name:`NonStandard.query.${Math.random()}`,text:s,values:n});return(await Z.any(r)).map((t=>t.rev))}static async insert({id:t,rev:e,publicKeys:a,classHash:s}){const n=new o.PreparedStatement({name:`NonStandard.insert.${Math.random()}`,text:'INSERT INTO "NonStandard"("id", "rev", "publicKeys", "classHash", "spent") VALUES ($1, $2, $3, $4, FALSE) ON CONFLICT DO NOTHING',values:[t,e,a,s]});await Z.none(n)}static async update(t){const e=new o.PreparedStatement({name:`NonStandard.update.${Math.random()}`,text:'UPDATE "NonStandard" SET "spent" = TRUE WHERE "rev" = $1 AND "spent" = FALSE',values:[t]});return Z.none(e)}static async getRevsByIds(t){const e=new o.PreparedStatement({name:`NonStandard.getRevsByIds.${Math.random()}`,text:'SELECT "rev" FROM "NonStandard" WHERE "id" LIKE ANY($1) AND "spent" = FALSE',values:[[t]]});return Z.any(e)}static async select(t){const e=new o.PreparedStatement({name:`NonStandard.select.${Math.random()}`,text:'SELECT "id", "classHash" FROM "NonStandard" WHERE "rev" = $1',values:[t]});return Z.oneOrNone(e)}}class dt{static async select(t){return ct.select(t)}static async query(t){return ct.query(t)}static async getRevsByIds(t){return ct.getRevsByIds(t)}static async insert(t){return ct.insert(t)}static async update(t){return ct.update(t)}}const{crypto:lt}=c.Bitcoin;var pt=async(t,e,a)=>{const s=Math.max(t.length,e.length);const n=G(t,s);const r=G(e,s);const o=(i=r,n.map(((t,e)=>[t,i[e]])));var i;await Promise.all(o.map((async([t,e],s)=>{const{__cls:n="",_owners:r=[]}=a[s]||{};if(null===t&&e)return/^[0-9A-Fa-f]{64}\/\d+$/.test(e),void await dt.insert({id:e,rev:e,publicKeys:r,classHash:lt.Hash.sha256(Buffer.from(n)).toString("hex")});if(e&&t){const{id:a="",classHash:s=""}=await dt.select(t)||{};await dt.insert({id:a,classHash:s,rev:e,publicKeys:r}),await dt.update(t)}})))};var ut=async t=>{for(let e=0;e<t.length;e+=1)try{const{tx:a,txId:s,inRevs:n=[],outRevs:r=[],outData:o=[]}=t[e];await it(a.outputs,a.id),await nt(a.inputs),await pt(n,r,o),D.info(`Synced to '${s}'`)}catch(a){a.message.includes("duplicate key value violates unique constraint")||D.error(`Processing tx ${t[e].tx.id} failed with error '${a.message}'`)}};const{CHAIN:St,NETWORK:yt,BCN_URL:ft}=x;const gt=new t.Computer({chain:St,network:yt,url:ft});const Et=async(t,e,a)=>{try{let{result:s}=await k.getBlockHash(t);for(;t<=e;){const{result:n}=await k.getBlock(s,2);const{tx:r,nextblockhash:o}=n;const i=`Backfilling progress ${t}/${e} blocks [${(t/e*100).toFixed(4)}% (bitcoind progress: ${(100*a).toFixed(4)}%)] Backfilling ${r.length} transactions...`;D.info(i);const c=await Promise.all(r.map((t=>gt.db.fromTxHex(t.hex))));await ut(c),await tt({syncedHeight:t,bitcoindSyncedHeight:e,bitcoindSyncedProgress:a}),s=o,t+=1}}catch(t){D.error(`Sync action failed with error '${t.message}'`)}};!function(){try{const t=`Synchronizing { url: ${x.BCN_URL}, chain:${x.CHAIN} network:${x.NETWORK} }`;D.info(t),"regtest"!==x.NETWORK&&(async()=>{await(async()=>{await e.backOff((()=>Z.connect()),{startingDelay:j})})(),await(async()=>{try{let t=await e.backOff((()=>(async()=>{const t=await k.getBlockchainInfo();const e=(100*parseFloat(t.result.verificationprogress)).toFixed(4);const{blocks:a}=t.result;const s=`Bitcoind Synced Progress { percentage:${e}%, blocks:${a} }`;if(D.info(s),parseFloat(t.result.verificationprogress)<=1e-6)throw new Error("Node not ready yet");return t})()),{startingDelay:5e3,timeMultiple:1,numOfAttempts:720});let a=await J();await tt({syncedHeight:a.syncedHeight,bitcoindSyncedHeight:t.result.blocks,bitcoindSyncedProgress:t.result.verificationprogress});let s=Math.max(x.SYNC_HEIGHT,a.syncedHeight+1);const n=(100*parseFloat(t.result.verificationprogress)).toFixed(4);const r=t.result.blocks;const{syncedHeight:o}=a;const i=`Starting sync process { bitcoind.progress:${n}%, bitcoindSyncedHeight:${r}, syncedHeight:${o}, currentBlockHeight:${s} }`;for(D.info(i);parseFloat(t.result.verificationprogress)<.999||s<=a.bitcoindSyncedHeight;){await Et(s,a.bitcoindSyncedHeight,t.result.verificationprogress),t=await k.getBlockchainInfo(),a=await J(),a.bitcoindSyncedHeight=t.result.blocks,await tt({syncedHeight:a.syncedHeight,bitcoindSyncedHeight:a.bitcoindSyncedHeight,bitcoindSyncedProgress:t.result.verificationprogress});const e=(100*parseFloat(t.result.verificationprogress)).toFixed(4);D.info(`Bitcoind progress: ${e}%`),s=a.syncedHeight+1}}catch(t){D.error(`Sync action failed with error '${t.message}'`)}})()})()}catch(t){D.error(`Synchronizing failed with error '${t.message}'`)}}();
