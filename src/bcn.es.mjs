import t from"body-parser";import e from"cors";import s from"express";import a from"http";import*as r from"zeromq";import n from"express-rate-limit";import o from"dotenv";import{createLogger as i,format as c,transports as d}from"winston";import{Bitcoin as u}from"bitcoin-computer-bitcore";import l,{PreparedStatement as y}from"pg-promise";import m from"pg-monitor";import S from"bitcoind-rpc";import f from"hash.js";import T from"util";import{Computer as R}from"bitcoin-computer-lib";import{ec as g}from"elliptic";import h from"fs";import E from"path";o.config();const{PORT:p=3e3,ZMQ_URL:w="tcp://litecoind:28332",CHAIN:v="LTC",NETWORK:O="regtest",BCN_ENV:N="dev",BCN_URL:$="http://127.0.0.1:3000",DEBUG_MODE:P=1,POSTGRES_USER:_="bcn",POSTGRES_PASSWORD:b="bcn",POSTGRES_DB:x="bcn",POSTGRES_HOST:C="127.0.0.1",POSTGRES_PORT:I=5432,RPC_PROTOCOL:A="http",RPC_USER:H="bcn-admin",RPC_PASSWORD:j="kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=",RPC_HOST:U="litecoind",RPC_PORT:B=19332,SERVER_VERSION:L=.1,DEFAULT_WALLET:M="defaultwallet"}=process.env;var G={PORT:p,ZMQ_URL:w,CHAIN:v,NETWORK:O,BCN_ENV:N,BCN_URL:$,DEBUG_MODE:P,POSTGRES_USER:_,POSTGRES_PASSWORD:b,POSTGRES_DB:x,POSTGRES_HOST:C,POSTGRES_PORT:I,POSTGRES_MAX_PARAM_NUM:65535,RPC_PROTOCOL:A,RPC_USER:H,RPC_PASSWORD:j,RPC_HOST:U,RPC_PORT:B,SYNC_HEIGHT:1,SYNC_INTERVAL_CHECK:3e3,SERVER_VERSION:L,DB_CONNECTION_RETRY_TIME:3e3,SIGNATURE_FRESHNESS_MINUTES:3,DEFAULT_WALLET:M};const D=i({level:"info",format:c.json(),transports:[new d.File({filename:"error.log",level:"error"}),new d.File({filename:"combined.log"})]});D.add(new d.Console({format:c.combine(c.colorize(),c.timestamp({format:"YYYY-MM-DD HH:mm:ss"}),c.printf((t=>`${t.level} ${t.message} [2m${t.timestamp}[0m`)))}));const W=()=>"dev"===G.BCN_ENV;const k=()=>new S({protocol:G.RPC_PROTOCOL,user:G.RPC_USER,pass:G.RPC_PASSWORD,host:G.RPC_HOST,port:G.RPC_PORT});const F=t=>new Promise((e=>{setTimeout(e,t)}));const K={error:(t,e)=>{e.cn&&D.info(`Connection to db failed: ${JSON.stringify(e.cn)} ${t}`)},noWarnings:!0};W()&&"1"===G.DEBUG_MODE&&(m.isAttached()?m.detach():(m.attach(K),m.setTheme("matrix")));const V=l(K)({host:G.POSTGRES_HOST,port:G.POSTGRES_PORT,database:G.POSTGRES_DB,user:G.POSTGRES_USER,password:G.POSTGRES_PASSWORD,allowExitOnIdle:!0,idleTimeoutMillis:100});class z{static async find(t){const e=new y({name:"OffChainStore.find",text:'SELECT "data" FROM "OffChainStore" WHERE "id" = $1',values:[t]});const s=await V.oneOrNone(e);return s?s.data.toString():s}static async save(t,e){const s=new y({name:"OffChainStore.save",text:'INSERT INTO "OffChainStore" ("id", "data") VALUES ($1, $2) ON CONFLICT DO NOTHING',values:[t,e]});return V.none(s)}static async delete(t){const e=new y({name:"OffChainStore.delete",text:'WITH deleted AS (DELETE FROM "OffChainStore" WHERE "id" = $1 RETURNING *) SELECT count(*) FROM deleted;',values:[t]});return(await V.any(e))[0].count>0}}class Y{static async get(t){return z.find(t)}static async set(t,e){return z.save(t,e)}static async delete(t){return z.delete(t)}}const{crypto:q}=u;const J=s.Router();J.get("/:id",(async({params:{id:t},url:e,method:s},a)=>{void 0===a.locals.authToken&&(D.error(`Authorization failed at ${s} ${e}.`),a.status(403).json({error:`Authorization failed at ${s} ${e}.`}));try{const e=await Y.get(t);e?a.status(200).json(e):a.status(403).json({error:"No entry found."})}catch(t){D.error(`GET ${e} failed with error: ${t.message}`),a.status(500).json({error:t.message})}})),J.post("/",(async(t,e)=>{const{body:{data:s},url:a}=t;try{const a=q.Hash.sha256(Buffer.from(s)).toString("hex");await Y.set(a,s);const r=`${t.protocol}://${t.get("host")}/store/${a}`;e.status(201).json({_url:r})}catch(t){D.error(`POST ${a} failed with error: ${t.message}`),e.status(500).json({error:t.message})}})),J.delete("/:id",(async({params:{id:t},url:e,method:s},a)=>{W()||(D.error(`Authorization failed at ${s} ${e}.`),a.status(403).json({error:`Authorization failed at ${s} ${e}.`}));try{await Y.delete(t)?a.status(204).send():a.status(403).json({error:"No entry found."})}catch(t){D.error(`${s} ${e} failed with error: ${t.message}`),a.status(500).json({error:t.message})}}));class Z{static async findByRevId(t){const e=new y({name:"NonStandardTxo.findByRevId",text:'SELECT "rev", "contractName", "contractHash" FROM "NonStandardTxos" WHERE "rev" = $1',values:[t]});return V.oneOrNone(e)}static async findManyNonStandardUtxos(t){const{publicKey:e,contractName:s,contractHash:a}=t;if(void 0===e&&void 0===s&&void 0===a)return[];let r='SELECT "rev", "contractName", "contractHash" FROM "NonStandardTxos"';let n=' WHERE "spent" = false';let o="findManyNonStandardUtxos";const i=[];e&&(o+=(0===i.length?"By":"And")+"PublicKey",i.push(e),n+=' AND "publicKey" = $1'),s&&(o+=(0===i.length?"By":"And")+"ContractName",i.push(s),n+=` AND "contractName" = $${i.length}`),a&&(o+=(0===i.length?"By":"And")+"ContractHash",i.push(a),n+=` AND "contractHash" = $${i.length}`),r+=n;const c=new y({name:o,text:r,values:i});return V.any(c)}static async saveNonStandardUtxo(t,e,s,a){const r=new y({name:"NonStandardTxo.saveNonStandardUtxo",text:'INSERT INTO "NonStandardTxos"("publicKey", "rev", "spent", "contractName", "contractHash") VALUES ($1, $2, false, $3, $4)',values:[e,t,s,a]});await V.none(r)}static async updateSpent(t){const e=new y({name:"NonStandardTxo.updateSpent",text:'UPDATE "NonStandardTxos" SET "spent" = true WHERE "rev" = $1',values:[t]});await V.none(e)}}class Q{static async getNonStandardTxoByRevId(t){return Z.findByRevId(t)}static async queryNonStandardUtxos(t){return Z.findManyNonStandardUtxos(t)}static async addNonStandardUtxo(t,e,s,a){return Z.saveNonStandardUtxo(t,e,s,a)}static async updateSpent(t){return Z.updateSpent(t)}}class X{static async findById(t){const e=new y({name:"IdToRev.findById",text:'SELECT "rev" FROM "IdToRev" WHERE id = $1',values:[t]});return V.any(e)}static async findManyById(t){const e=new y({name:"IdToRev.findManyById",text:'SELECT "id", "rev" FROM "IdToRev" WHERE "id" LIKE ANY($1)',values:[[t]]});return V.any(e)}static async save(t,e){const s=new y({name:"IdToRev.save",text:'INSERT INTO "IdToRev" (id, rev) VALUES ($1, $2)',values:[t,e]});await V.any(s)}static async update(t,e){const s=new y({name:"IdToRev.update",text:'UPDATE "IdToRev" SET rev = $1 WHERE rev = $2',values:[t,e]});await V.any(s)}}class tt{static async getRev(t){return X.findById(t)}static async getRevs(t){const e=await X.findManyById(t);const s=new Map(e.map((t=>[t.id,t.rev])));return t.map((t=>s.has(t)?s.get(t):null))}static async addRev(t,e){return X.save(t,e)}static async updateRev(t,e){return X.update(t,e)}}function et(t){return function(t){if(!/^[0-9A-Fa-f]{64}\/\d+$/.test(t))throw new Error(`Invalid outId: ${t}`)}(t),{rev:t}}var st=async(t,e,s)=>{try{if(Array.isArray(e)&&Array.isArray(s)&&t){const r=(t,e)=>Object.assign(new Array(e).fill(null),t);const n=Math.max(e.length,s.length);const o=r(e,n);const i=r(s,n);const c=s.length;const d=(a=i,o.map(((t,e)=>[t,a[e]])));const u=JSON.parse(t);if(u.length!==s.length)return;await Promise.all(d.map((async([t,e],s)=>{const a=u[s];const r=!!t&&!!e;const n=c>0;let o="";let i="";if(null===t&&e){const{__cls:t}=a;t&&(o=(t=>{const e=t.startsWith("export ")?t.slice(7):t;return(e.startsWith("default ")?e.slice(8):e).split(" ")[1]})(t),i=f.sha256().update(t).digest("hex")),await tt.addRev(e,e)}else if(r){const s=et(t);const a=await Q.getNonStandardTxoByRevId(s.rev);o=null==a?void 0:a.contractName,i=null==a?void 0:a.contractHash,await tt.updateRev(e,t),await Q.updateSpent(s.rev)}if(n){const t=et(e);await Promise.all(a._owners.map((e=>Q.addNonStandardUtxo(t.rev,e,o,i))))}})))}}catch(t){if(!t.message.includes("duplicate key value violates unique constraint"))throw t}var a};class at{static async findById(t){const e=new y({name:"Transaction.findById",text:'SELECT tx FROM "Transactions" WHERE id = $1',values:[t]});const s=await V.oneOrNone(e);return null===s?null:s.tx.toString()}static async save(t,e){const s=new y({name:"Transaction.save",text:'INSERT INTO "Transactions"(id, tx) VALUES ($1, $2) ON CONFLICT DO NOTHING',values:[t,e]});await V.none(s)}}class rt{static async getTransaction(t){return at.findById(t)}static async getBulkTransactions(t,e,s){return Promise.all(s.map((t=>at.findById(t))))}static async addTransaction(t,e){await at.save(t,e)}static async broadcastRawTransaction(t){const e=k();const s=T.promisify(S.prototype.sendRawTransaction.bind(e));const{result:a}=await s(t);return await this.addTransaction(a,t),a}}var nt=async t=>await rt.getTransaction(t);var ot=async t=>{const e=k();const s=T.promisify(S.prototype.importaddress.bind(e));const a=T.promisify(S.prototype.getaddressinfo.bind(e));const r=T.promisify(S.prototype.listunspent.bind(e));return void 0===(await a(t)).result.timestamp&&(D.info(`Importing address: ${t}`),await s(t,!1)),(await r(0,999999,[t])).result};const{CHAIN:it,NETWORK:ct,BCN_URL:dt}=G;const ut=new R({chain:it,network:ct,url:dt});class lt{static async getProgress(){return V.one('SELECT "syncedHeight", "bitcoindSyncedHeight", "bitcoindSyncedProgress" FROM "SyncProgress"')}static async saveProgress(t,e,s){const a=new y({name:"SyncProgress.save",text:'UPDATE "SyncProgress" SET "syncedHeight" = $1, "bitcoindSyncedHeight" = $2, "bitcoindSyncedProgress" = $3',values:[t,e,s]});await V.any(a)}}var yt=async()=>class{static async getProgress(){return lt.getProgress()}static async saveProgres(t,e,s){await lt.saveProgress(t,e,s)}}.getProgress();const mt=async t=>{const e=t.toString("hex");try{D.info(`Message on topic "rawTx": ${e}`),await(async t=>{let e;let s;let a;let r;try{({inRevs:e,outRevs:s,outData:a,txId:r}=await ut.db.fromTxHex(t))}catch(e){"dev"===G.BCN_ENV&&D.error(`Error parsing transaction "${t}": ${e}`)}if(a.length)try{await st(JSON.stringify(a),e,s),await(async(t,e)=>{await rt.addTransaction(t,e)})(r,t),D.info(`Synced to "${r}"`)}catch(e){D.error(`Error syncing to "${t}": ${e}`)}})(e)}catch(t){D.error(`RawTxSubscriber failed with error: ${t.message}`)}};const St=new g("secp256k1");const ft=s();let Tt;try{Tt=a.createServer(ft)}catch(t){throw D.error(`Starting server failed with error: ${t.message}`),t}if(D.info(`Server listening on port ${G.PORT}`),ft.use(e()),"dev"!==G.BCN_ENV){const t=n({windowMs:9e5,max:300,standardHeaders:!0,legacyHeaders:!1});ft.use(t)}ft.use(t.json({limit:"100mb"})),ft.use(t.urlencoded({limit:"100mb",extended:!0})),ft.use((async(t,e,s)=>{try{const a=t.get("Authentication");if(!a)return void s();const r=(t=>{const e=t.split(" ");if(2!==e.length||"Bearer"!==e[0])throw new Error("Authentication header is invalid.");const s=Buffer.from(e[1],"base64").toString().split(":");if(3!==s.length)throw new Error;return{signature:s[0],publicKey:s[1],timestamp:parseInt(s[2],10)}})(a);const{signature:n,publicKey:o,timestamp:i}=r;if(Date.now()-i>1e3*G.SIGNATURE_FRESHNESS_MINUTES*60)return void e.status(401).json({error:"Signature is too old."});const c=f.sha256().update(G.BCN_URL+i).digest("hex");if(!St.keyFromPublic(o,"hex").verify(c,n))return void e.status(401).json({error:"The origin and public key pair doesn't match the signature."});e.locals.authToken=r,s()}catch(t){e.status(401).json({error:t.message})}})),ft.use((({url:t},e,s)=>{if(void 0!==e.locals.authToken)try{let t;try{const e=W()?"bcn.test.config.json":"bcn.config.json";t=h.readFileSync(E.join(__dirname,"..","..",e))}catch(t){if(t.message.includes("ENOENT: no such file or directory"))return void s();throw t}const{blacklist:a,whitelist:r}=JSON.parse(t.toString());if(a&&r)return void e.status(403).json({error:"Cannot enfore blacklist and whitelist at the same time."});const{publicKey:n}=e.locals.authToken;if(r&&!r.includes(n)||a&&a.includes(n))return void e.status(403).json({error:`Public key ${n} is not allowed.`});s()}catch(s){D.error(`Authorization failed at ${t} with error: ${s.message}`),e.status(403).json({error:s.message})}else s()}));const Rt=(()=>{const t=s.Router();return t.post("/non-standard-utxo",(async({body:t,url:e},s)=>{try{if(!t||"object"!=typeof t)return void s.status(500).json({error:"Parameter must be an object"});const{outData:e,inRevs:a,outRevs:r}=t;await st(e,a,r),s.status(201).json({status:"Success"})}catch(t){D.error(`POST ${e} failed with error: ${t.message}`),s.status(500).json({error:t.message})}})),t.get("/wallet/:publicKey/non-standard-utxos",(async({params:t,url:e},s)=>{try{const{publicKey:e}=t;const a=await(async t=>await Q.queryNonStandardUtxos({publicKey:t}))(e);s.status(200).json(a)}catch(t){D.error(`GET ${e} failed with error: ${t.message}`),s.status(404).json({error:t.message})}})),t.get("/wallet/:address/utxos",(async({params:t,url:e},s)=>{try{const{address:e}=t;const a=await ot(e);s.status(200).json(a)}catch(t){D.error(`GET ${e} failed with error: ${t.message}`),s.status(404).json({error:t.message})}})),t.get("/non-standard-utxos",(async({query:t,url:e},s)=>{try{const{publicKey:e,contractName:a,contractHash:r}=t;const n=await(async(t,e,s)=>(await Q.queryNonStandardUtxos({publicKey:t,contractName:e,contractHash:s})).map((t=>t.rev)))(e,a,r);s.status(200).json(n)}catch(t){D.error(`GET ${e} failed with error: ${t.messages}`),s.status(404).json({error:t.message})}})),t.get("/address/:address/balance",(async({params:t,url:e},s)=>{try{const{address:e}=t;const a=(await ot(e)).reduce(((t,e)=>t+e.amount),0);s.status(200).json(1e8*a)}catch(t){D.error(`GET ${e} failed with error: ${t.message}`),s.status(404).json({error:t.message})}})),t.get("/tx/:txId",(async({params:t,url:e},s)=>{try{const{txId:e}=t;const a=await nt(e);a?s.status(200).json(a):s.status(404).json({error:"Not found"})}catch(t){D.error(`GET ${e} failed with error: ${t.message}`),s.status(500).json({error:t.message})}})),t.get("/tx-data/:txId",(async({params:t,url:e},s)=>{try{const{txId:e}=t;const a=await nt(e);a?s.status(200).json({hex:a}):s.status(404).json({error:"Not found"})}catch(t){D.error(`GET ${e} failed with error: ${t.message}`),s.status(500).json({error:t.message})}})),t.post("/tx/bulk",(async({params:t,body:{txIds:e},url:s},a)=>{try{if(void 0===e||0===e.length)return void a.status(500).json({error:"Missing input txIds."});const{chain:s,network:r}=t;const n=await(async(t,e,s)=>await rt.getBulkTransactions(t,e,s))(s,r,e);n?a.status(200).json(n):a.status(404).json({error:"Not found"})}catch(t){D.error(`POST ${s} failed with error: ${t.message}`),a.status(500).json({error:t.message})}})),t.post("/tx/send",(async({body:{rawTx:t},url:e},s)=>{try{const e=await(async t=>await rt.broadcastRawTransaction(t))(t);s.status(200).json(e)}catch(t){D.error(`POST ${e} failed with error: ${t.message}`),s.status(500).json({error:t.message})}})),t.get("/rev/:id/:outNum",(async({params:t,url:e},s)=>{try{const{id:e,outNum:a}=t;const r=await(async t=>await tt.getRev(t))(`${e}/${a}`);s.status(200).json(r)}catch(t){D.error(`GET ${e} failed with error: ${t.message}`),s.status(404).json({error:t.message})}})),t.post("/revs",(async({body:{ids:t},url:e},s)=>{try{if(void 0===t||0===t.length)return void s.status(404).json({error:"Missing input object ids."});const e=await(async t=>await tt.getRevs(t))(t);s.status(200).json(e)}catch(t){D.error(`POST ${e} failed with error: ${t.message}`),s.status(404).json({error:t.message})}})),t})();ft.use(`/v1/${G.CHAIN}/${G.NETWORK}`,Rt),ft.use("/v1/store",J),ft.get("/",((t,e)=>e.status(200).send("OK"))),ft.get("/health",((t,e)=>e.status(200).send("healthy"))),Tt.listen(G.PORT,(()=>{D.info(`Rev ${G.SERVER_VERSION} Started web server on port ${G.PORT}`)}));const gt=new r.Subscriber;gt.connect(G.ZMQ_URL),gt.subscribe("raw"),D.info(`ZMQ Subscriber connected to ${G.ZMQ_URL}`),(async()=>{let t=!1;do{try{await V.connect(),t=!0}catch(t){D.info(`Re-trying db connection: HOST=${G.POSTGRES_HOST}, PORT=${G.POSTGRES_PORT}, DATABASE=${G.POSTGRES_DB} USER=${G.POSTGRES_USER}`)}await F(G.DB_CONNECTION_RETRY_TIME)}while(!t)})().then((()=>{(async t=>{try{await(async()=>{try{const t=k();const e=T.promisify(S.prototype.createwallet.bind(t));const s=await e(G.DEFAULT_WALLET);D.info(`Wallet created succesfully: ${JSON.stringify(s)}`)}catch(t){D.info(`Create wallet status: ${JSON.stringify(t,null,2)}`)}})(),"regtest"!==G.NETWORK&&await(async()=>{let t={};let e=-1;let s=-1;let a=0;D.info(`Checking sync progress...syncedHeight: ${e} from ${s}`);do{t=await yt(),e=t.syncedHeight,s=t.bitcoindSyncedHeight,a=t.bitcoindSyncedProgress,e>0?D.info(`Sync progress ${e}/${s} blocks [${(e/s*100).toFixed(4)}% (bitcoind progress: ${(100*a).toFixed(4)}%)]`):D.info(`Sync progress initializing... ${e}/${s} blocks `),await F(G.SYNC_INTERVAL_CHECK)}while(e<s||a<.999);D.info(`BCN reaches sync end...currentBlockHeight: ${e} from ${s} (chain progress: ${(100*a).toFixed(4)})`)})(),D.info("Waiting for zmq messages...");for await(const[e,s]of t)"rawtx"===e.toString()&&mt(s),"rawblock"===e.toString()&&D.info(`rawblock msg: ${s}`)}catch(t){D.error(`run zmqSock failed with error: ${t.message}`)}})(gt)}));
