import t from"body-parser";import e from"cors";import s from"express";import n from"http";import*as a from"zeromq";import r from"express-rate-limit";import o from"dotenv";import{createLogger as i,format as c,transports as d}from"winston";import{Bitcoin as u}from"bitcoin-computer-bitcore";import l,{PreparedStatement as y}from"pg-promise";import S from"pg-monitor";import m from"bitcoind-rpc";import p from"crypto";import f from"util";import{Computer as g}from"bitcoin-computer-lib";import h from"hash.js";import{ec as T}from"elliptic";import R from"fs";import E from"path";o.config();const{PORT:w=3e3,ZMQ_URL:$="tcp://litecoind:28332",CHAIN:O="LTC",NETWORK:N="regtest",BCN_ENV:x="dev",BCN_URL:v="http://127.0.0.1:3000",DEBUG_MODE:P=1,POSTGRES_USER:b="bcn",POSTGRES_PASSWORD:_="bcn",POSTGRES_DB:I="bcn",POSTGRES_HOST:C="127.0.0.1",POSTGRES_PORT:B=5432,RPC_PROTOCOL:A="http",RPC_USER:U="bcn-admin",RPC_PASSWORD:H="kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=",RPC_HOST:M="litecoind",RPC_PORT:j=19332,SERVER_VERSION:L=.1,DEFAULT_WALLET:G="defaultwallet"}=process.env;var D={PORT:w,ZMQ_URL:$,CHAIN:O,NETWORK:N,BCN_ENV:x,BCN_URL:v,DEBUG_MODE:P,POSTGRES_USER:b,POSTGRES_PASSWORD:_,POSTGRES_DB:I,POSTGRES_HOST:C,POSTGRES_PORT:B,POSTGRES_MAX_PARAM_NUM:1e4,RPC_PROTOCOL:A,RPC_USER:U,RPC_PASSWORD:H,RPC_HOST:M,RPC_PORT:j,SYNC_HEIGHT:1,SYNC_INTERVAL_CHECK:3e3,SERVER_VERSION:L,DB_CONNECTION_RETRY_TIME:3e3,SIGNATURE_FRESHNESS_MINUTES:3,DEFAULT_WALLET:G};const K=i({level:"info",format:c.json(),transports:[new d.File({filename:"error.log",level:"error"}),new d.File({filename:"combined.log"})]});K.add(new d.Console({format:c.combine(c.colorize(),c.timestamp({format:"YYYY-MM-DD HH:mm:ss"}),c.printf((t=>`${t.level} ${t.message} [2m${t.timestamp}[0m`)))}));const{PublicKey:W}=u;const F=()=>"dev"===D.BCN_ENV;const k=()=>D.DEBUG_MODE>0;const V=()=>D.DEBUG_MODE>1;const Y=(t,e)=>{if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++){const n=t[s];const a=Object.keys(n);let r=!1;for(let t=0;t<e.length;t++){const s=e[t];const o=Object.keys(s);if(a.length===o.length&&a.every((t=>o.includes(t)))&&a.every((t=>n[t]===s[t]))){r=!0;break}}if(!r)return!1}return!0};const z=()=>new m({protocol:D.RPC_PROTOCOL,user:D.RPC_USER,pass:D.RPC_PASSWORD,host:D.RPC_HOST,port:D.RPC_PORT});const q=t=>new Promise((e=>{setTimeout(e,t)}));const J=t=>t.isPublicKeyOut()?new W(t.getPublicKey()).toAddress(D.NETWORK).toString("legacy"):t.toAddress(D.NETWORK).toString("legacy");const Z={error:(t,e)=>{e.cn&&K.info(`Connection to db failed: ${JSON.stringify(e.cn)} ${t}`)},noWarnings:!0};F()&&k()&&(S.isAttached()?S.detach():(S.attach(Z),S.setTheme("matrix")));const Q=l(Z)({host:D.POSTGRES_HOST,port:D.POSTGRES_PORT,database:D.POSTGRES_DB,user:D.POSTGRES_USER,password:D.POSTGRES_PASSWORD,allowExitOnIdle:!0,idleTimeoutMillis:100});class X{static async find(t){const e=new y({name:"OffChainStore.find",text:'SELECT "data" FROM "OffChainStore" WHERE "id" = $1',values:[t]});const s=await Q.oneOrNone(e);return s?s.data.toString():s}static async save(t,e){const s=new y({name:"OffChainStore.save",text:'INSERT INTO "OffChainStore" ("id", "data") VALUES ($1, $2) ON CONFLICT DO NOTHING',values:[t,e]});return Q.none(s)}static async delete(t){const e=new y({name:"OffChainStore.delete",text:'WITH deleted AS (DELETE FROM "OffChainStore" WHERE "id" = $1 RETURNING *) SELECT count(*) FROM deleted;',values:[t]});return(await Q.any(e))[0].count>0}}class tt{static async get(t){return X.find(t)}static async set(t,e){return X.save(t,e)}static async delete(t){return X.delete(t)}}const{crypto:et}=u;const st=s.Router();st.get("/:id",(async({params:{id:t},url:e,method:s},n)=>{void 0===n.locals.authToken&&(K.error(`Authorization failed at ${s} ${e}.`),n.status(403).json({error:`Authorization failed at ${s} ${e}.`}));try{const e=await tt.get(t);e?n.status(200).json(e):n.status(403).json({error:"No entry found."})}catch(t){K.error(`GET ${e} failed with error: ${t.message}`),n.status(500).json({error:t.message})}})),st.post("/",(async(t,e)=>{const{body:{data:s},url:n}=t;try{const n=et.Hash.sha256(Buffer.from(s)).toString("hex");await tt.set(n,s);const a=`${t.protocol}://${t.get("host")}/store/${n}`;e.status(201).json({_url:a})}catch(t){K.error(`POST ${n} failed with error: ${t.message}`),e.status(500).json({error:t.message})}})),st.delete("/:id",(async({params:{id:t},url:e,method:s},n)=>{F()||(K.error(`Authorization failed at ${s} ${e}.`),n.status(403).json({error:`Authorization failed at ${s} ${e}.`}));try{await tt.delete(t)?n.status(204).send():n.status(403).json({error:"No entry found."})}catch(t){K.error(`${s} ${e} failed with error: ${t.message}`),n.status(500).json({error:t.message})}}));class nt{static async countByRev(t){if(!t.length)return 0;let e=t.map((t=>`('${t.prevTxId.toString("hex")}/${t.outputIndex}')`)).join(",");e=`(  ${e} )`;const s=new y({name:`NonStandardTxos.countByRev$${p.randomBytes(10).toString("hex")}`,text:`SELECT count("rev") FROM "NonStandardTxos" WHERE "rev" IN ${e}`});const n=await Q.oneOrNone(s);return parseInt(null==n?void 0:n.count,10)||0}static async findNonStandardTxoByRev(t){const e=new y({name:"NonStandardTxo.findNonStandardTxoByRev",text:'SELECT "rev", "contractName", "contractHash" FROM "NonStandardTxos" WHERE "rev" = $1',values:[t]});return Q.oneOrNone(e)}static async findRevById(t){const e=new y({name:"NonStandardTxo.findRevById",text:'SELECT "rev" FROM "NonStandardTxos" WHERE "id" = $1',values:[t]});return Q.any(e)}static async findManyNonStandardUtxosRevsById(t){const e=new y({name:"NonStandardTxo.findManyRevsById",text:'SELECT "rev" FROM "NonStandardTxos" WHERE "id" LIKE ANY($1)',values:[[t]]});return Q.any(e)}static async findManyNonStandardUtxos(t){const{publicKey:e,contractName:s,contractHash:n}=t;if(void 0===e&&void 0===s&&void 0===n)return[];let a='SELECT "rev", "contractName", "contractHash" FROM "NonStandardTxos"';let r=' WHERE "rev" IS NOT NULL';let o="findManyNonStandardUtxos";const i=[];e&&(o+=(0===i.length?"By":"And")+"PublicKeys",i.push(e),r+=' AND $1 = ANY ("publicKeys")'),s&&(o+=(0===i.length?"By":"And")+"ContractName",i.push(s),r+=` AND "contractName" = $${i.length}`),n&&(o+=(0===i.length?"By":"And")+"ContractHash",i.push(n),r+=` AND "contractHash" = $${i.length}`),a+=r;const c=new y({name:o,text:a,values:i});return Q.any(c)}static async saveNonStandardUtxo(t,e,s,n,a){const r=new y({name:"NonStandardTxo.saveNonStandardUtxo",text:'INSERT INTO "NonStandardTxos"("id", "rev", "publicKeys", "contractName", "contractHash") VALUES ($1, $2, $3, $4, $5)',values:[t,e,s,n,a]});await Q.none(r)}static async updateNonStandardTxo(t,e,s){const n=new y({name:"NonStandardTxo.updateNonStandardTxo",text:'UPDATE "NonStandardTxos" SET "rev" = $1, "publicKeys" = $3 WHERE "rev" = $2',values:[t,e,s]});await Q.none(n)}}class at{static async getNonStandardTxoByRevId(t){return nt.findNonStandardTxoByRev(t)}static async queryNonStandardUtxos(t){return nt.findManyNonStandardUtxos(t)}static async getRev(t){return nt.findRevById(t)}static async getRevs(t){return nt.findManyNonStandardUtxosRevsById(t)}static async addNonStandardUtxo(t,e,s,n,a){return nt.saveNonStandardUtxo(t,e,s,n,a)}static async updateNonStandardTxo(t,e,s){return nt.updateNonStandardTxo(t,e,s)}static async getCount(t){return nt.countByRev(t)}}class rt{static async countByTxIdVout(t){if(!t.length)return 0;let e=t.map((t=>`('${t.prevTxId.toString("hex")}/${t.outputIndex}')`)).join(",");e=`( ${e} )`;const s=new y({name:`StandardUtxos.countByTxIdVout$${p.randomBytes(10).toString("hex")}`,text:`SELECT count("rev") FROM "StandardUtxos" WHERE "rev" IN ${e}`});const n=await Q.oneOrNone(s);return parseInt(null==n?void 0:n.count,10)||0}static async findManyByAddress(t){const e=new y({name:"StandardUtxos.findManyByAddress",text:'SELECT "address", ("satoshis"/100000000.0) AS "amount", "satoshis", "scriptPubKey", "rev" FROM "StandardUtxos" WHERE "address" = $1',values:[t]});return(await Q.any(e)).map((t=>({...t,amount:parseFloat(t.amount),satoshis:parseInt(t.satoshis,10)})))}static async getBalance(t){const e=new y({name:"StandardUtxos.getBalance",text:'SELECT SUM("satoshis") FROM "StandardUtxos" WHERE "address" = $1',values:[t]});const s=await Q.oneOrNone(e);return parseInt(null==s?void 0:s.sum,10)||0}static async saveBatch(t){const e=t.flatMap((t=>[`${t.txId}/${t.outputIndex}`,t.address.toString("legacy"),t.satoshis,t.script.toHex()]));for(;e.length;){const t=e.splice(0,D.POSTGRES_MAX_PARAM_NUM);const s=[];for(let e=1;e<=t.length;e+=4)s.push(`($${e}, $${e+1}, $${e+2}, $${e+3})`);const n=s.join(",");const a=new y({name:`StandardUtxos.saveBatch$${p.randomBytes(10).toString("hex")}`,text:`INSERT INTO "StandardUtxos"("rev", "address", "satoshis", "scriptPubKey") VALUES ${n}  ON CONFLICT DO NOTHING`,values:t});await Q.none(a)}}static async deleteSpentBatch(t){const e=t.flatMap((t=>[`${t.prevTxId.toString("hex")}/${t.outputIndex}`]));const s=D.POSTGRES_MAX_PARAM_NUM;for(;e.length;){const t=e.splice(0,s);const n=[];for(let e=1;e<=t.length;e+=1)n.push(`("rev" = $${e})`);const a=n.join(" OR ");const r=new y({name:`StandardUtxos.deleteSpentBatch${p.randomBytes(10).toString("hex")}`,text:`DELETE FROM "StandardUtxos" WHERE ${a}`,values:t});await Q.none(r)}}}class ot{static async getUtxosFromAddress(t){return rt.findManyByAddress(t)}static async getBalance(t){return rt.getBalance(t)}static async getCount(t){return rt.countByTxIdVout(t)}}var it=async t=>await ot.getUtxosFromAddress(t);const ct=z();const dt=f.promisify(m.prototype.getRawTransaction.bind(ct));const ut=f.promisify(m.prototype.sendRawTransaction.bind(ct));class lt{static async getTransaction(t){const{result:e}=await dt(t);return e}static async getBulkTransactions(t){return(await Promise.all(t.map((t=>dt(t))))).map((t=>t.result))}static async broadcastRawTransaction(t){const{result:e}=await ut(t);return e}}var yt=async t=>{const e=z();const s=f.promisify(m.prototype.importaddress.bind(e));const n=f.promisify(m.prototype.getaddressinfo.bind(e));const a=f.promisify(m.prototype.listunspent.bind(e));return void 0===(await n(t)).result.timestamp&&(K.info(`Importing address: ${t}`),await s(t,!1)),(await a(0,999999,[t])).result};function St(t){if(!/^[0-9A-Fa-f]{64}\/\d+$/.test(t))throw new Error(`Invalid outId: ${t}`)}const mt=(t,e)=>Object.assign(new Array(e).fill(null),t);var pt=async(t,e,s)=>{if(Array.isArray(e)&&Array.isArray(s)&&t){const a=Math.max(e.length,s.length);const r=mt(e,a);const o=mt(s,a);const i=(n=o,r.map(((t,e)=>[t,n[e]])));if(t.length!==s.length)return;await Promise.all(i.map((async([e,s],n)=>{const{__cls:a="",_owners:r=[]}=t[n];const o=!!e&&!!s;if(null===e&&s){const t=(t=>{if(!t.length)return"";const e=t.startsWith("export ")?t.slice(7):t;return(e.startsWith("default ")?e.slice(8):e).split(" ")[1]})(a);const e=h.sha256().update(a).digest("hex");St(s),await at.addNonStandardUtxo(s,s,r,t,e)}else o&&(St(e),await at.updateNonStandardTxo(s,e,r))})))}var n};const{Transaction:ft}=u;const{Input:gt}=ft;const{Script:ht,Transaction:Tt}=u;const{UnspentOutput:Rt}=Tt;class Et{static async getProgress(){return Q.one('SELECT "syncedHeight", "bitcoindSyncedHeight", "bitcoindSyncedProgress" FROM "SyncProgress"')}static async saveProgress(t,e,s){const n=new y({name:"SyncProgress.save",text:'UPDATE "SyncProgress" SET "syncedHeight" = $1, "bitcoindSyncedHeight" = $2, "bitcoindSyncedProgress" = $3',values:[t,e,s]});await Q.any(n)}}var wt=async()=>class{static async getProgress(){return Et.getProgress()}static async saveProgres(t,e,s){await Et.saveProgress(t,e,s)}}.getProgress();const{Transaction:$t}=u;const{Input:Ot}=$t;const{CHAIN:Nt,NETWORK:xt,BCN_URL:vt}=D;const Pt=new g({chain:Nt,network:xt,url:vt});const bt=async t=>{try{const e=t.toString("hex");K.info(`Message on topic "rawTx": ${e}`);const s=await Pt.db.fromTxHex(e);await(async t=>{const e=t.map((t=>Ot.fromObject({...t,script:t._scriptBuffer}))).filter((t=>!t.isNull()));const s=await(async t=>await ot.getCount(t))(e);const n=await(async t=>await at.getCount(t))(e);return s+n<e.length})(s.tx.inputs)||(await(async t=>{for(let e=0;e<t.length;e+=1)try{const{inRevs:s,outRevs:n,outData:a,txId:r}=t[e];if(!(null==a?void 0:a.length))return;await pt(a,s,n),K.info(`Synced to "${r}"`)}catch(s){K.error(`Failed processing ${JSON.stringify(t[e])} because of ${s.message}`)}})([s]),await(async t=>{const e=t.flatMap((({tx:t})=>t.inputs));const s=t.flatMap((({tx:t})=>t.outputs.map(((e,s)=>{const n=e;return n.txId=t.id,n.n=s,n}))));await(async t=>{try{const e=t.filter((t=>{try{const e=ht.fromBuffer(t._scriptBuffer);return e.isPublicKeyHashOut()||e.isPublicKeyOut()}catch(t){return!1}})).map((t=>{const e=ht.fromBuffer(t._scriptBuffer);return new Rt({address:J(e),txId:t.txId,outputIndex:t.n,scriptPubKey:e.toHex(),amount:t._satoshis/1e8,satoshis:Math.round(t._satoshis)})}));return rt.saveBatch(e)}catch(t){if(!t.message.includes("duplicate key value violates unique constraint"))throw t;return Promise.resolve(void 0)}})(s),await(async t=>{const e=t.map((t=>gt.fromObject({...t,script:t._scriptBuffer}))).filter((t=>!t.isNull()));return rt.deleteSpentBatch(e)})(e)})([s]))}catch(t){K.error(`RawTxSubscriber failed with error: ${t.message}`)}};const _t=new T("secp256k1");const It=s();let Ct;try{Ct=n.createServer(It)}catch(t){throw K.error(`Starting server failed with error: ${t.message}`),t}if(K.info(`Server listening on port ${D.PORT}`),It.use(e()),"dev"!==D.BCN_ENV){const t=r({windowMs:9e5,max:300,standardHeaders:!0,legacyHeaders:!1});It.use(t)}It.use(t.json({limit:"100mb"})),It.use(t.urlencoded({limit:"100mb",extended:!0})),It.use((async(t,e,s)=>{try{const n=t.get("Authentication");if(!n)return void s();const a=(t=>{const e=t.split(" ");if(2!==e.length||"Bearer"!==e[0])throw new Error("Authentication header is invalid.");const s=Buffer.from(e[1],"base64").toString().split(":");if(3!==s.length)throw new Error;return{signature:s[0],publicKey:s[1],timestamp:parseInt(s[2],10)}})(n);const{signature:r,publicKey:o,timestamp:i}=a;if(Date.now()-i>1e3*D.SIGNATURE_FRESHNESS_MINUTES*60)return void e.status(401).json({error:"Signature is too old."});const c=h.sha256().update(D.BCN_URL+i).digest("hex");if(!_t.keyFromPublic(o,"hex").verify(c,r))return void e.status(401).json({error:"The origin and public key pair doesn't match the signature."});e.locals.authToken=a,s()}catch(t){e.status(401).json({error:t.message})}})),It.use((({url:t},e,s)=>{if(void 0!==e.locals.authToken)try{let t;try{const e=F()?"bcn.test.config.json":"bcn.config.json";t=R.readFileSync(E.join(__dirname,"..","..",e))}catch(t){if(t.message.includes("ENOENT: no such file or directory"))return void s();throw t}const{blacklist:n,whitelist:a}=JSON.parse(t.toString());if(n&&a)return void e.status(403).json({error:"Cannot enfore blacklist and whitelist at the same time."});const{publicKey:r}=e.locals.authToken;if(a&&!a.includes(r)||n&&n.includes(r))return void e.status(403).json({error:`Public key ${r} is not allowed.`});s()}catch(s){K.error(`Authorization failed at ${t} with error: ${s.message}`),e.status(403).json({error:s.message})}else s()}));const Bt=(()=>{const t=s.Router();return t.get("/wallet/:publicKey/non-standard-utxos",(async({params:t,url:e},s)=>{try{const{publicKey:e}=t;const n=await(async t=>await at.queryNonStandardUtxos({publicKey:t}))(e);s.status(200).json(n)}catch(t){K.error(`GET ${e} failed with error: ${t.message}`),s.status(404).json({error:t.message})}})),t.get("/wallet/:address/utxos",(async({params:t,url:e},s)=>{try{const{address:e}=t;const n=await it(e);const a=n.map((({amount:t,rev:e})=>{const[s,n]=e.split("/");return{amount:t,txid:s,vout:parseInt(n,10)}}));if(k()){const t=(await yt(e)).map((({amount:t,txid:e,vout:s})=>({amount:t,txid:e,vout:s})));Y(a,t)||(K.error(`Inconsistency on UTXO set calculation for address ${e}.`),K.error(`db utxos ${JSON.stringify(a,null,2)} rpc utxos: ${JSON.stringify(t,null,2)}`),V()&&process.abort())}s.status(200).json(n)}catch(t){K.error(`GET ${e} failed with error: ${t.message}`),s.status(404).json({error:t.message})}})),t.get("/non-standard-utxos",(async({query:t,url:e},s)=>{try{const{publicKey:e,contractName:n,contractHash:a}=t;const r=await(async(t,e,s)=>(await at.queryNonStandardUtxos({publicKey:t,contractName:e,contractHash:s})).map((t=>t.rev)))(e,n,a);s.status(200).json(r)}catch(t){K.error(`GET ${e} failed with error: ${t.messages}`),s.status(404).json({error:t.message})}})),t.get("/address/:address/balance",(async({params:t,url:e},s)=>{try{const{address:e}=t;const n=await it(e);const a=await(async t=>await ot.getBalance(t))(e);const r=n.map((({amount:t,rev:e})=>{const[s,n]=e.split("/");return{amount:t,txid:s,vout:parseInt(n,10)}}));if(k()){const t=await yt(e);const s=1e8*t.reduce(((t,e)=>t+e.amount),0);const n=t.map((({amount:t,txid:e,vout:s})=>({amount:t,txid:e,vout:s})));a===Math.round(s)&&Y(r,n)||(K.error(`Inconsistency on balance calculation for address ${e}: dbBalance ${a} rpcBalance: ${s}`),K.error(`db utxos ${JSON.stringify(r,null,2)} rpc utxos: ${JSON.stringify(n,null,2)}`),V()&&process.abort())}s.status(200).json(a)}catch(t){K.error(`GET ${e} failed with error: ${t.message}`),s.status(404).json({error:t.message})}})),t.get("/tx/:txId",(async({params:t,url:e},s)=>{try{const{txId:e}=t;const n=await(async t=>await lt.getTransaction(t))(e);n&&s.status(200).json(n)}catch(t){K.error(`GET ${e} failed with error: ${t.message}`),s.status(500).json({error:t.message})}})),t.post("/tx/bulk",(async({body:{txIds:t},url:e},s)=>{try{if(void 0===t||0===t.length)return void s.status(500).json({error:"Missing input txIds."});const e=await(async t=>await lt.getBulkTransactions(t))(t);e?s.status(200).json(e):s.status(404).json({error:"Not found"})}catch(t){K.error(`POST ${e} failed with error: ${t.message}`),s.status(500).json({error:t.message})}})),t.post("/tx/send",(async({body:{rawTx:t},url:e},s)=>{try{const e=await(async t=>await lt.broadcastRawTransaction(t))(t);s.status(200).json(e)}catch(t){K.error(`POST ${e} failed with error: ${t.message}`),s.status(500).json({error:t.message})}})),t.get("/rev/:id/:outNum",(async({params:t,url:e},s)=>{try{const{id:e,outNum:n}=t;const a=await(async t=>at.getRev(t))(`${e}/${n}`);s.status(200).json(a)}catch(t){K.error(`GET ${e} failed with error: ${t.message}`),s.status(404).json({error:t.message})}})),t.post("/revs",(async({body:{ids:t},url:e},s)=>{try{if(void 0===t||0===t.length)return void s.status(404).json({error:"Missing input object ids."});const e=await(async t=>(await at.getRevs(t)).map((t=>t.rev)))(t);s.status(200).json(e)}catch(t){K.error(`POST ${e} failed with error: ${t.message}`),s.status(404).json({error:t.message})}})),t.post("/non-standard-utxo",(async(t,e)=>{e.status(500).json({error:"Please upgrade to bitcoin-computer-lib@0.7.7.0-beta or greater."})})),t})();It.use(`/v1/${D.CHAIN}/${D.NETWORK}`,Bt),It.use("/v1/store",st),It.get("/",((t,e)=>e.status(200).send("OK"))),It.get("/health",((t,e)=>e.status(200).send("healthy"))),Ct.listen(D.PORT,(()=>{K.info(`Rev ${D.SERVER_VERSION} Started web server on port ${D.PORT}`)}));const At=new a.Subscriber;At.connect(D.ZMQ_URL),At.subscribe("rawtx"),K.info(`ZMQ Subscriber connected to ${D.ZMQ_URL}`),(async()=>{let t=!1;do{try{await Q.connect(),t=!0}catch(t){K.info(`Re-trying db connection: HOST=${D.POSTGRES_HOST}, PORT=${D.POSTGRES_PORT}, DATABASE=${D.POSTGRES_DB} USER=${D.POSTGRES_USER}`)}await q(D.DB_CONNECTION_RETRY_TIME)}while(!t)})().then((()=>{(async t=>{try{"regtest"!==D.NETWORK&&await(async()=>{let t=-1;let e=-1;let s=0;K.info("Checking sync progress...syncedHeight: -1 from -1");do{({syncedHeight:t,bitcoindSyncedHeight:e,bitcoindSyncedProgress:s}=await wt()),t>0?K.info(`Sync progress ${t}/${e} blocks [${(t/e*100).toFixed(4)}% (bitcoind progress: ${(100*s).toFixed(4)}%)]`):K.info(`Sync progress initializing... ${t}/${e} blocks `),await q(D.SYNC_INTERVAL_CHECK)}while(t<e||s<.999);K.info(`BCN reaches sync end...currentBlockHeight: ${t} from ${e} (chain progress: ${(100*s).toFixed(4)})`)})(),K.info("Waiting for zmq messages...");for await(const[,e]of t)await bt(e)}catch(t){K.error(`run zmqSock failed with error: ${t.message}`)}})(At)}));
