import t from"body-parser";import e from"cors";import s from"express";import r from"http";import*as a from"zeromq";import n from"express-rate-limit";import o from"dotenv";import{createLogger as i,format as c,transports as d}from"winston";import{Bitcoin as l}from"bitcoin-computer-bitcore";import u,{PreparedStatement as p}from"pg-promise";import m from"pg-monitor";import{backOff as h}from"exponential-backoff";import{Computer as g}from"bitcoin-computer-lib";import y from"fs";import f from"bitcoind-rpc";import S from"util";import{ec as w}from"elliptic";import E from"hash.js";import R from"path";o.config();const{PORT:T="3000",ZMQ_URL:$="tcp://litecoind:28332",CHAIN:O="LTC",NETWORK:v="regtest",BCN_ENV:b="dev",BCN_URL:N="http://127.0.0.1:3000",DEBUG_MODE:P="1",POSTGRES_USER:x="bcn",POSTGRES_PASSWORD:_="bcn",POSTGRES_DB:C="bcn",POSTGRES_HOST:I="127.0.0.1",POSTGRES_PORT:A="5432",RPC_PROTOCOL:H="http",RPC_USER:M="bcn-admin",RPC_PASSWORD:j="kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=",RPC_HOST:B="litecoind",RPC_PORT:L="19332",SERVER_VERSION:U="0.1",DEFAULT_WALLET:D="defaultwallet"}=process.env;var F={PORT:parseInt(T,10),ZMQ_URL:$,CHAIN:O,NETWORK:v,BCN_ENV:b,BCN_URL:N,DEBUG_MODE:parseInt(P,10),POSTGRES_USER:x,POSTGRES_PASSWORD:_,POSTGRES_DB:C,POSTGRES_HOST:I,POSTGRES_PORT:parseInt(A,10),POSTGRES_MAX_PARAM_NUM:1e4,RPC_PROTOCOL:H,RPC_USER:M,RPC_PASSWORD:j,RPC_HOST:B,RPC_PORT:parseInt(L,10),SYNC_HEIGHT:1,SYNC_INTERVAL_CHECK:3e3,SERVER_VERSION:U,DB_CONNECTION_RETRY_TIME:500,SIGNATURE_FRESHNESS_MINUTES:3,DEFAULT_WALLET:D,allowedRPCMethods:[/^get/,/Accounts$/]};const{DEBUG_MODE:G}=F;const k=i({level:["error","warn","info","http","verbose","debug","silly"][G],format:c.json(),transports:[new d.Console({format:c.combine(c.colorize(),c.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),c.printf((t=>`[2m${t.timestamp}[0m ${t.level} ${t.message}`)))})],exceptionHandlers:[new d.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new d.File({filename:"logs/rejections.log"})]});const W={maxFiles:1,maxSize:1e5};G>=0&&k.add(new d.File({filename:"error.log",level:"error"})),G>=1&&k.add(new d.File({filename:"logs/warn.log",level:"warn",...W})),G>=2&&k.add(new d.File({filename:"logs/info.log",level:"info",...W})),G>=3&&k.add(new d.File({filename:"logs/http.log",level:"http",...W})),G>=4&&k.add(new d.File({filename:"logs/verbose.log",level:"verbose",...W})),G>=5&&k.add(new d.File({filename:"logs/debug.log",level:"debug",...W}));const K=()=>"dev"===F.BCN_ENV;const V=()=>F.DEBUG_MODE>=6;const Y=(t,e)=>{if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++){const r=t[s];const a=Object.keys(r);let n=!1;for(let t=0;t<e.length;t++){const s=e[t];const o=Object.keys(s);if(a.length===o.length&&a.every((t=>o.includes(t)))&&a.every((t=>r[t]===s[t]))){n=!0;break}}if(!n)return!1}return!0};const z=t=>new Promise((e=>{setTimeout(e,t)}));const q=(t,e)=>Object.assign(new Array(e).fill(null),t);const{POSTGRES_HOST:J,POSTGRES_PORT:Z,POSTGRES_DB:Q,POSTGRES_USER:X,POSTGRES_PASSWORD:tt,DB_CONNECTION_RETRY_TIME:et}=F;const st={error:(t,e)=>{if(e.cn){const{host:s,port:r,database:a,user:n,password:o}=e.cn;k.debug(`Waiting for db to start { message:${t.message} host:${s}, port:${r}, database:${a}, user:${n}, password: ${o}`)}},noWarnings:!0};K()&&F.DEBUG_MODE>0&&(m.isAttached()?m.detach():(m.attach(st),m.setTheme("matrix")));const rt=u(st)({host:J,port:Z,database:Q,user:X,password:tt,allowExitOnIdle:!0,idleTimeoutMillis:100});class at{static async select(t){const e=new p({name:`OffChain.select.${Math.random()}`,text:'SELECT "data" FROM "OffChain" WHERE "id" = $1',values:[t]});return rt.oneOrNone(e)}static async insert({id:t,data:e}){const s=new p({name:`OffChain.insert.${Math.random()}`,text:'INSERT INTO "OffChain" ("id", "data") VALUES ($1, $2) ON CONFLICT DO NOTHING',values:[t,e]});return rt.none(s)}static async delete(t){const e=new p({name:`OffChain.delete.${Math.random()}`,text:'WITH deleted AS (DELETE FROM "OffChain" WHERE "id" = $1 RETURNING *) SELECT count(*) FROM deleted;',values:[t]});return(await rt.any(e))[0].count>0}}class nt{static async select(t){const e=await at.select(t);return(null==e?void 0:e.data)||null}static async insert(t){return at.insert(t)}static async delete(t){return at.delete(t)}}const{crypto:ot}=l;const it=s.Router();it.get("/:id",(async({params:{id:t},url:e,method:s},r)=>{void 0===r.locals.authToken&&(k.error(`Authorization failed at ${s} ${e}.`),r.status(403).json({error:`Authorization failed at ${s} ${e}.`}));try{const e=await nt.select(t);e?r.status(200).json(e):r.status(403).json({error:"No entry found."})}catch(t){k.error(`GET ${e} failed with error '${t.message}'`),r.status(500).json({error:t.message})}})),it.post("/",(async(t,e)=>{const{body:{data:s},url:r}=t;try{const r=ot.Hash.sha256(Buffer.from(s)).toString("hex");await nt.insert({id:r,data:s});const a=`${t.protocol}://${t.get("host")}/store/${r}`;e.status(201).json({_url:a})}catch(t){k.error(`POST ${r} failed with error '${t.message}'`),e.status(500).json({error:t.message})}})),it.delete("/:id",(async({params:{id:t},url:e,method:s},r)=>{K()||(k.error(`Authorization failed at ${s} ${e}.`),r.status(403).json({error:`Authorization failed at ${s} ${e}.`}));try{await nt.delete(t)?r.status(204).send():r.status(403).json({error:"No entry found."})}catch(t){k.error(`DELETE ${e} failed with error '${t.message}'`),r.status(500).json({error:t.message})}}));class ct{static async select(){return rt.one('SELECT "syncedHeight", "bitcoindSyncedHeight", "bitcoindSyncedProgress" FROM "Sync"')}static async update({syncedHeight:t,bitcoindSyncedHeight:e,bitcoindSyncedProgress:s}){const r=new p({name:`Sync.update.${Math.random()}`,text:'UPDATE "Sync" SET "syncedHeight" = $1, "bitcoindSyncedHeight" = $2, "bitcoindSyncedProgress" = $3',values:[t,e,s]});await rt.any(r)}}var dt=async()=>class{static async select(){return ct.select()}static async update(t){await ct.update(t)}}.select();const lt={protocol:F.RPC_PROTOCOL,user:F.RPC_USER,pass:F.RPC_PASSWORD,host:F.RPC_HOST,port:F.RPC_PORT};const ut=new f(lt);const pt={createwallet:S.promisify(f.prototype.createwallet.bind(ut)),generateToAddress:S.promisify(f.prototype.generateToAddress.bind(ut)),getaddressinfo:S.promisify(f.prototype.getaddressinfo.bind(ut)),getBlock:S.promisify(f.prototype.getBlock.bind(ut)),getBlockchainInfo:S.promisify(f.prototype.getBlockchainInfo.bind(ut)),getBlockHash:S.promisify(f.prototype.getBlockHash.bind(ut)),getRawTransaction:S.promisify(f.prototype.getRawTransaction.bind(ut)),getTransaction:S.promisify(f.prototype.getTransaction.bind(ut)),importaddress:S.promisify(f.prototype.importaddress.bind(ut)),listunspent:S.promisify(f.prototype.listunspent.bind(ut)),sendRawTransaction:S.promisify(f.prototype.sendRawTransaction.bind(ut))};class mt{static async getTransaction(t){const{result:e}=await pt.getTransaction(t);return e}static async getBulkTransactions(t){return(await Promise.all(t.map((t=>pt.getRawTransaction(t))))).map((t=>t.result))}static async sendRawTransaction(t){const{result:e,error:s}=await pt.sendRawTransaction(t);if(s)throw k.error(s),new Error("Error sending transaction");return e}}class ht{static async select(t){const e=new p({name:`Standard.select.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev" FROM "Standard" WHERE "address" = $1 AND "spent" = FALSE',values:[t]});return(await rt.any(e)).map((t=>({...t,satoshis:parseInt(t.satoshis,10)})))}static async insert(t){const e=t.flatMap((t=>[t.rev,t.address,t.satoshis,t.scriptPubKey,!1]));for(;e.length;){const t=e.splice(0,F.POSTGRES_MAX_PARAM_NUM);const s=[];for(let e=1;e<=t.length;e+=5)s.push(`($${e}, $${e+1}, $${e+2}, $${e+3}, $${e+4})`);const r=s.join(",");const a=new p({name:`Standard.insert.${Math.random()}`,text:`INSERT INTO "Standard"("rev", "address", "satoshis", "scriptPubKey", "spent") VALUES ${r}  ON CONFLICT DO NOTHING`,values:t});await rt.none(a)}}static async update(t){const e=t.flatMap((t=>[`${t.prevTxId.toString("hex")}/${t.outputIndex}`]));if(0===e.length)return[];const s=[];for(let t=1;t<=e.length;t+=1)s.push(`("rev" = $${t})`);const r=s.join(" OR ");const a=new p({name:`Standard.update.${Math.random()}`,text:`UPDATE "Standard" SET "spent" = TRUE WHERE ${r} RETURNING "rev"`,values:e});return rt.any(a)}static async getBalance(t){const e=new p({name:`Standard.getBalance.${Math.random()}`,text:'SELECT SUM("satoshis") FROM "Standard" WHERE "address" = $1 AND "spent" = FALSE',values:[t]});const s=await rt.oneOrNone(e);return parseInt(null==s?void 0:s.sum,10)||0}}class gt{static async select(t){return(await ht.select(t)).map((t=>({...t,amount:t.satoshis/1e8})))}static async getBalance(t){return ht.getBalance(t)}static async insert(t){const e=t.map((t=>({rev:`${t.txId}/${t.outputIndex}`,address:t.address.toString("legacy"),satoshis:t.satoshis,scriptPubKey:t.script.toHex(),spent:!1})));return ht.insert(e)}}const{Script:yt,Transaction:ft}=l;const{Transaction:St}=l;const{Input:wt}=St;class Et{static async query(t){const{publicKey:e,classHash:s}=t;if(void 0===e&&void 0===s)return[];let r='SELECT "rev"\n      FROM "NonStandard"\n      WHERE "spent" = FALSE';const a=[];e&&(a.push(e),r+=' AND $1 = ANY ("publicKeys")'),s&&(a.push(s),r+=` AND "classHash" = $${a.length}`);const n=new p({name:`NonStandard.query.${Math.random()}`,text:r,values:a});return(await rt.any(n)).map((t=>t.rev))}static async insert({id:t,rev:e,publicKeys:s,classHash:r}){const a=new p({name:`NonStandard.insert.${Math.random()}`,text:'INSERT INTO "NonStandard"("id", "rev", "publicKeys", "classHash", "spent") VALUES ($1, $2, $3, $4, FALSE) ON CONFLICT DO NOTHING',values:[t,e,s,r]});await rt.none(a)}static async update(t){const e=new p({name:`NonStandard.update.${Math.random()}`,text:'UPDATE "NonStandard" SET "spent" = TRUE WHERE "rev" = $1 AND "spent" = FALSE',values:[t]});return rt.none(e)}static async getRevsByIds(t){const e=new p({name:`NonStandard.getRevsByIds.${Math.random()}`,text:'SELECT "rev" FROM "NonStandard" WHERE "id" LIKE ANY($1) AND "spent" = FALSE',values:[[t]]});return rt.any(e)}static async select(t){const e=new p({name:`NonStandard.select.${Math.random()}`,text:'SELECT "id", "classHash" FROM "NonStandard" WHERE "rev" = $1',values:[t]});return rt.oneOrNone(e)}}class Rt{static async select(t){return Et.select(t)}static async query(t){return Et.query(t)}static async getRevsByIds(t){return Et.getRevsByIds(t)}static async insert(t){return Et.insert(t)}static async update(t){return Et.update(t)}}const{crypto:Tt}=l;const{CHAIN:$t,NETWORK:Ot,BCN_URL:vt}=F;const bt=new g({chain:$t,network:Ot,url:vt});const Nt=t=>t.tx.inputs.map((t=>l.Transaction.Input.fromObject({...t,script:t._scriptBuffer}))).filter((t=>!t.isNull()));const Pt=async t=>{const e=Nt(t);if(e.length>0){const s=await(async t=>{const e=Nt(t);let s=[];return e.length>0&&(s=await(async t=>{const e=await class{static async areSpent(t){return class{static async areSpent(t){const e=t.map((t=>`('${t.prevTxId.toString("hex")}/${t.outputIndex}')`)).join(",");const s=new p({name:`Utxos.areSpent.${Math.random()}`,text:`SELECT "rev", "stSpent", "nstSpent" from "Utxos"  WHERE "rev" IN (${e})`});return rt.any(s)}}.areSpent(t)}}.areSpent(t);return e})(e)),s})(t);const r=e.flatMap((t=>{const e=`${t.prevTxId.toString("hex")}/${t.outputIndex}`;return s.some((t=>t.rev===e))?[]:[t]}));await Promise.all(r.map((async t=>{const e=await(async t=>await mt.getTransaction(t))(t.prevTxId.toString("hex"));const s=await bt.db.fromTxId(e.id);await Pt(s)})))}await(async(t,e)=>{const s=t.flatMap(((t,s)=>{const r=yt.fromBuffer(t._scriptBuffer);const{PUBKEYHASH_OUT:a,SCRIPTHASH_OUT:n}=yt.types;if(![a,n].includes(r.classify()))return[];const o=r.toAddress(F.NETWORK).toString("legacy");const i=r.toHex();const c=t.satoshis/1e8;const d=Math.round(t.satoshis);return[new ft.UnspentOutput({address:o,txId:e,outputIndex:s,scriptPubKey:i,amount:c,satoshis:d})]}));await gt.insert(s)})(t.tx.outputs,t.txId),await(async t=>{const e=t.map((t=>wt.fromObject({...t,script:t._scriptBuffer}))).filter((t=>!t.isNull()));return ht.update(e)})(t.tx.inputs);const{inRevs:s=[],outRevs:r=[],outData:a=[]}=t;await(async(t,e,s)=>{const r=Math.max(t.length,e.length);const a=q(t,r);const n=q(e,r);const o=(i=n,a.map(((t,e)=>[t,i[e]])));var i;await Promise.all(o.map((async([t,e],r)=>{const{__cls:a="",_owners:n=[]}=s[r]||{};if(null===t&&e)return/^[0-9A-Fa-f]{64}\/\d+$/.test(e),void await Rt.insert({id:e,rev:e,publicKeys:n,classHash:Tt.Hash.sha256(Buffer.from(a)).toString("hex")});if(e&&t){const{id:s="",classHash:r=""}=await Rt.select(t)||{};await Rt.insert({id:s,classHash:r,rev:e,publicKeys:n}),await Rt.update(t)}})))})(s,r,a)};const xt=async t=>{try{const e=t.toString("hex");k.info(`ZMQ message { rawTx:${e} }`),"dev"===F.BCN_ENV&&y.appendFileSync("zmqlog.log",`${e} \r\n`);const s=await bt.db.fromTxHex(e);try{await Pt(s)}catch(t){k.error(`Error parsing transaction ${t.message}`)}}catch(t){k.error(`RawTxSubscriber failed with error '${t.message}'`)}};var _t=async t=>gt.select(t);var Ct=async t=>await mt.getBulkTransactions(t);var It=async t=>(void 0===(await pt.getaddressinfo(t)).result.timestamp&&(k.info(`Importing address: ${t}`),await pt.importaddress(t,!1)),(await pt.listunspent(0,999999,[t])).result);const At={protocol:F.RPC_PROTOCOL,user:F.RPC_USER,pass:F.RPC_PASSWORD,host:F.RPC_HOST,port:F.RPC_PORT};const Ht=new f(At);const Mt={};const jt=JSON.parse(JSON.stringify(f.callspec));const Bt={str:t=>t.toString(),string:t=>t.toString(),int:t=>parseFloat(t),float:t=>parseFloat(t),bool:t=>!0===t||"1"===t||1===t||"true"===t||"true"===t.toString().toLowerCase(),obj:t=>"string"==typeof t?JSON.parse(t):t};try{Object.keys(f.prototype).forEach((t=>{t&&"function"==typeof f.prototype[t]&&(Mt[t]=S.promisify(f.prototype[t].bind(Ht)))}))}catch(t){k.error(`Error occurred while binding RPC methods: ${t.message}`)}const Lt=new w("secp256k1");const Ut=s();let Dt;try{Dt=r.createServer(Ut)}catch(t){throw k.error(`Starting server failed with error '${t.message}'`),t}if(k.info(`Server listening on port ${F.PORT}`),Ut.use(e()),"dev"!==F.BCN_ENV){const t=n({windowMs:9e5,max:300,standardHeaders:!0,legacyHeaders:!1});Ut.use(t)}Ut.use(t.json({limit:"100mb"})),Ut.use(t.urlencoded({limit:"100mb",extended:!0})),Ut.use((async(t,e,s)=>{try{const r=t.get("Authentication");if(!r)return void s();const a=(t=>{const e=t.split(" ");if(2!==e.length||"Bearer"!==e[0])throw new Error("Authentication header is invalid.");const s=Buffer.from(e[1],"base64").toString().split(":");if(3!==s.length)throw new Error;return{signature:s[0],publicKey:s[1],timestamp:parseInt(s[2],10)}})(r);const{signature:n,publicKey:o,timestamp:i}=a;if(Date.now()-i>1e3*F.SIGNATURE_FRESHNESS_MINUTES*60)return void e.status(401).json({error:"Signature is too old."});const c=E.sha256().update(F.BCN_URL+i).digest("hex");if(!Lt.keyFromPublic(o,"hex").verify(c,n))return void e.status(401).json({error:"The origin and public key pair doesn't match the signature."});e.locals.authToken=a,s()}catch(t){k.error(`Auth failed with error '${t.message}'`),e.status(401).json({error:t.message})}})),Ut.use((({url:t},e,s)=>{if(void 0!==e.locals.authToken)try{let t;try{const e=K()?"bcn.test.config.json":"bcn.config.json";t=y.readFileSync(R.join(__dirname,"..","..",e))}catch(t){if(t.message.includes("ENOENT: no such file or directory"))return void s();throw k.error(`Access-list failed with error '${t.message}'`),t}const{blacklist:r,whitelist:a}=JSON.parse(t.toString());if(r&&a)return void e.status(403).json({error:"Cannot enforce blacklist and whitelist at the same time."});const{publicKey:n}=e.locals.authToken;if(a&&!a.includes(n)||r&&r.includes(n))return void e.status(403).json({error:`Public key ${n} is not allowed.`});s()}catch(s){k.error(`Authorization failed at ${t} with error: '${s.message}'`),e.status(403).json({error:s.message})}else s()}));const Ft=(()=>{const t=s.Router();return t.get("/wallet/:address/utxos",(async({params:t,url:e},s)=>{try{const{address:e}=t;const r=await _t(e);const a=r.map((({satoshis:t,rev:e})=>{const[s,r]=e.split("/");return{amount:t/1e8,txid:s,vout:parseInt(r,10)}}));if(V()){let t=[];let s=!1;let r=10;do{try{t=await It(e)||[],s=!0}catch(t){k.debug(`Retrying to get utxos '${t.message}'`),await z(1e3),r-=1}}while(!s&&r>0);const n=t.map((({amount:t,txid:e,vout:s})=>({amount:t,txid:e,vout:s})));Y(a,n)||(k.error(`Inconsistency on UTXO set calculation for address ${e}.`),k.error(`db utxos ${JSON.stringify(a,null,2)} rpc utxos ${JSON.stringify(n,null,2)}`),k.error(`db utxos length ${a.length} rpc utxos length: ${n.length}`))}s.status(200).json(r)}catch(t){k.error(`GET ${e} failed with error '${t.message}'`),s.status(404).json({error:t.message})}})),t.get("/non-standard-utxos",(async({query:t,url:e},s)=>{try{const e=await(async t=>Rt.query(t))(t);s.status(200).json(e)}catch(t){k.error(`GET ${e} failed with error '${t.messages}'`),s.status(404).json({error:t.message})}})),t.get("/address/:address/balance",(async({params:t,url:e},s)=>{try{const{address:r}=t;const a=await _t(r);const n=await(async t=>gt.getBalance(t))(r);const o=a.map((({satoshis:t,rev:e})=>{const[s,r]=e.split("/");return{amount:t/1e8,txid:s,vout:parseInt(r,10)}}));if(V()){let t=[];let s=!1;let a=10;do{try{t=await It(r)||[],s=!0}catch(t){k.debug(`Retrying ${e} getStandardUtxosAction: ${t.message}`),await z(1e3),a-=1}}while(!s&&a>0);const i=1e8*t.reduce(((t,e)=>t+e.amount),0);const c=t.map((({amount:t,txid:e,vout:s})=>({amount:t,txid:e,vout:s})));n===Math.round(i)&&Y(o,c)||(k.error(`Inconsistency on balance calculation for address ${r}: dbBalance ${n} rpcBalance: ${i}`),k.error(`db utxos ${o}`),k.error(`rpc utxos: ${JSON.stringify(o)}`))}s.status(200).json(n)}catch(t){k.error(`GET ${e} failed with error '${t.message}'`),s.status(404).json({error:t.message})}})),t.post("/tx/bulk",(async({body:{txIds:t},url:e},s)=>{try{if(void 0===t||0===t.length)return void s.status(500).json({error:"Missing input txIds."});const e=await Ct(t);e?s.status(200).json(e):s.status(404).json({error:"Not found"})}catch(t){k.error(`POST ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.post("/tx/send",(async({body:{rawTx:t},url:e},s)=>{try{const e=await(async t=>mt.sendRawTransaction(t))(t);await xt(t),s.status(200).json(e)}catch(t){k.error(`POST ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.post("/revs",(async({body:{ids:t},url:e},s)=>{try{if(void 0===t||0===t.length)return void s.status(404).json({error:"Missing input object ids."});const e=await(async t=>(await Rt.getRevsByIds(t)).map((t=>t.rev)))(t);s.status(200).json(e)}catch(t){k.error(`POST ${e} failed with error '${t.message}'`),s.status(404).json({error:t.message})}})),t.post("/rpc",(async({body:t,url:e},s)=>{try{if(!t||!t.method)throw new Error("Please provide appropriate RPC method name");if(!F.allowedRPCMethods.some((e=>e.test(t.method))))throw new Error("Method is not allowed");const e=function(t,e){if(void 0===jt[t]||null===jt[t])throw new Error("This RPC method does not exist, or not supported");const s=e.trim().split(" ");const r=jt[t].trim().split(" ");if(0===e.trim().length&&0!==jt[t].trim().length)throw new Error(`Too few params provided. Expected ${r.length} Provided 0`);if(0!==e.trim().length&&0===jt[t].trim().length)throw new Error(`Too many params provided. Expected 0 Provided ${s.length}`);if(s.length<r.length)throw new Error(`Too few params provided. Expected ${r.length} Provided ${s.length}`);if(s.length>r.length)throw new Error(`Too many params provided. Expected ${r.length} Provided ${s.length}`);return 0===e.length?[]:s.map(((t,e)=>Bt[r[e]](t)))}(t.method,t.params);const r=e.length?await Mt[t.method](...e):await Mt[t.method]();return void s.status(200).json({result:r})}catch(t){k.error(`POST ${e} failed with error '${t.message}'`),s.status(404).json({error:t.message})}})),t.post("/non-standard-utxo",(async(t,e)=>{e.status(500).json({error:"Please upgrade to bitcoin-computer-lib@0.7.7.0-beta or greater."})})),t.get("/tx/:txId",(async({params:t},e)=>{const{txId:s}=t;const[r]=await Ct([s]);r?e.status(200).json(r):e.status(404).json({error:"Not found"})})),t})();Ut.use(`/v1/${F.CHAIN}/${F.NETWORK}`,Ft),Ut.use("/v1/store",it),Ut.get("/",((t,e)=>e.status(200).send("OK"))),Ut.get("/health",((t,e)=>e.status(200).send("healthy"))),Ut.get("/version",((t,e)=>e.status(200).send(F.SERVER_VERSION))),Dt.listen(F.PORT,(()=>{k.info(`Rev ${F.SERVER_VERSION} Started web server on port ${F.PORT}`)}));const Gt=new a.Subscriber;Gt.connect(F.ZMQ_URL),Gt.subscribe("rawtx"),k.info(`ZMQ Subscriber connected to ${F.ZMQ_URL}`),(async()=>{await(async()=>{await h((()=>rt.connect()),{startingDelay:et})})(),await(async t=>{try{await(async()=>{try{await pt.createwallet(F.DEFAULT_WALLET)}catch(t){k.debug(`Wallet creation failed with error '${t.message}'`)}})(),"regtest"!==F.NETWORK&&await(async()=>{let t=-1;let e=-1;let s=0;k.info("Checking sync progress...syncedHeight: -1 from -1");do{({syncedHeight:t,bitcoindSyncedHeight:e,bitcoindSyncedProgress:s}=await dt()),t>0?k.info(`Sync progress ${t}/${e} blocks [${(t/e*100).toFixed(4)}% (bitcoind progress: ${(100*s).toFixed(4)}%)]`):k.info(`Sync progress initializing... ${t}/${e} blocks `),await z(F.SYNC_INTERVAL_CHECK)}while(t<e||s<.999);k.info(`BCN reaches sync end...currentBlockHeight: ${t} from ${e} (chain progress: ${(100*s).toFixed(4)})`)})(),k.info("Bitcoin Computer Node is ready");for await(const[,e]of t)await xt(e)}catch(t){k.error(`ZMQ subscription failed with error '${t.message}'`)}})(Gt)})();
