"use strict";var t=require("body-parser");var e=require("cors");var r=require("express");var s=require("http");var a=require("zeromq");var n=require("express-rate-limit");var o=require("dotenv");var i=require("winston");var c=require("bitcoin-computer-bitcore");var d=require("pg-promise");var l=require("pg-monitor");var u=require("exponential-backoff");var p=require("bitcoin-computer-lib");var f=require("fs");var h=require("bitcoind-rpc");var m=require("util");var g=require("elliptic");var y=require("hash.js");var S=require("path");function E(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}function w(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((function(r){if("default"!==r){var s=Object.getOwnPropertyDescriptor(t,r);Object.defineProperty(e,r,s.get?s:{enumerable:!0,get:function(){return t[r]}})}})),e.default=t,Object.freeze(e)}var R=E(t);var T=E(e);var v=E(r);var $=E(s);var O=w(a);var b=E(n);var P=E(o);var N=E(d);var _=E(l);var x=E(f);var C=E(h);var I=E(m);var A=E(y);var H=E(S);P.default.config();const{PORT:M="3000",ZMQ_URL:j="tcp://litecoind:28332",CHAIN:L="LTC",NETWORK:B="regtest",BCN_ENV:D="dev",BCN_URL:U="http://127.0.0.1:3000",DEBUG_MODE:F="1",POSTGRES_USER:k="bcn",POSTGRES_PASSWORD:G="bcn",POSTGRES_DB:W="bcn",POSTGRES_HOST:q="127.0.0.1",POSTGRES_PORT:K="5432",RPC_PROTOCOL:V="http",RPC_USER:Y="bcn-admin",RPC_PASSWORD:z="kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=",RPC_HOST:J="litecoind",RPC_PORT:Z="19332",SERVER_VERSION:Q="0.1",DEFAULT_WALLET:X="defaultwallet"}=process.env;const tt=process.env.ALLOWED_RPC_METHODS?process.env.ALLOWED_RPC_METHODS.split(",").map((t=>new RegExp(t))):[];var et={PORT:parseInt(M,10),ZMQ_URL:j,CHAIN:L,NETWORK:B,BCN_ENV:D,BCN_URL:U,DEBUG_MODE:parseInt(F,10),POSTGRES_USER:k,POSTGRES_PASSWORD:G,POSTGRES_DB:W,POSTGRES_HOST:q,POSTGRES_PORT:parseInt(K,10),POSTGRES_MAX_PARAM_NUM:1e4,RPC_PROTOCOL:V,RPC_USER:Y,RPC_PASSWORD:z,RPC_HOST:J,RPC_PORT:parseInt(Z,10),SYNC_HEIGHT:1,SYNC_INTERVAL_CHECK:3e3,SERVER_VERSION:Q,DB_CONNECTION_RETRY_TIME:500,SIGNATURE_FRESHNESS_MINUTES:3,DEFAULT_WALLET:X,ALLOWED_RPC_METHODS:tt};const{DEBUG_MODE:rt}=et;const st=i.createLogger({level:["error","warn","info","http","verbose","debug","silly"][rt],format:i.format.json(),transports:[new i.transports.Console({format:i.format.combine(i.format.colorize(),i.format.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),i.format.printf((t=>`[2m${t.timestamp}[0m ${t.level} ${t.message}`)))})],exceptionHandlers:[new i.transports.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new i.transports.File({filename:"logs/rejections.log"})]});const at={maxFiles:1,maxSize:1e5};rt>=0&&st.add(new i.transports.File({filename:"error.log",level:"error"})),rt>=1&&st.add(new i.transports.File({filename:"logs/warn.log",level:"warn",...at})),rt>=2&&st.add(new i.transports.File({filename:"logs/info.log",level:"info",...at})),rt>=3&&st.add(new i.transports.File({filename:"logs/http.log",level:"http",...at})),rt>=4&&st.add(new i.transports.File({filename:"logs/verbose.log",level:"verbose",...at})),rt>=5&&st.add(new i.transports.File({filename:"logs/debug.log",level:"debug",...at}));const nt=()=>"dev"===et.BCN_ENV;const ot=()=>et.DEBUG_MODE>=6;const it=(t,e)=>{if(t.length!==e.length)return!1;for(let r=0;r<t.length;r++){const s=t[r];const a=Object.keys(s);let n=!1;for(let t=0;t<e.length;t++){const r=e[t];const o=Object.keys(r);if(a.length===o.length&&a.every((t=>o.includes(t)))&&a.every((t=>s[t]===r[t]))){n=!0;break}}if(!n)return!1}return!0};const ct=t=>new Promise((e=>{setTimeout(e,t)}));const dt=(t,e)=>Object.assign(new Array(e).fill(null),t);const{POSTGRES_HOST:lt,POSTGRES_PORT:ut,POSTGRES_DB:pt,POSTGRES_USER:ft,POSTGRES_PASSWORD:ht,DB_CONNECTION_RETRY_TIME:mt}=et;const gt={error:(t,e)=>{if(e.cn){const{host:r,port:s,database:a,user:n,password:o}=e.cn;st.debug(`Waiting for db to start { message:${t.message} host:${r}, port:${s}, database:${a}, user:${n}, password: ${o}`)}},noWarnings:!0};nt()&&et.DEBUG_MODE>0&&(_.default.isAttached()?_.default.detach():(_.default.attach(gt),_.default.setTheme("matrix")));const yt=N.default(gt)({host:lt,port:ut,database:pt,user:ft,password:ht,allowExitOnIdle:!0,idleTimeoutMillis:100});class St{static async select(t){const e=new d.PreparedStatement({name:`OffChain.select.${Math.random()}`,text:'SELECT "data" FROM "OffChain" WHERE "id" = $1',values:[t]});return yt.oneOrNone(e)}static async insert({id:t,data:e}){const r=new d.PreparedStatement({name:`OffChain.insert.${Math.random()}`,text:'INSERT INTO "OffChain" ("id", "data") VALUES ($1, $2) ON CONFLICT DO NOTHING',values:[t,e]});return yt.none(r)}static async delete(t){const e=new d.PreparedStatement({name:`OffChain.delete.${Math.random()}`,text:'WITH deleted AS (DELETE FROM "OffChain" WHERE "id" = $1 RETURNING *) SELECT count(*) FROM deleted;',values:[t]});return(await yt.any(e))[0].count>0}}class Et{static async select(t){const e=await St.select(t);return(null==e?void 0:e.data)||null}static async insert(t){return St.insert(t)}static async delete(t){return St.delete(t)}}const{crypto:wt}=c.Bitcoin;const Rt=v.default.Router();Rt.get("/:id",(async({params:{id:t},url:e,method:r},s)=>{void 0===s.locals.authToken&&(st.error(`Authorization failed at ${r} ${e}.`),s.status(403).json({error:`Authorization failed at ${r} ${e}.`}));try{const e=await Et.select(t);e?s.status(200).json(e):s.status(403).json({error:"No entry found."})}catch(t){st.error(`GET ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),Rt.post("/",(async(t,e)=>{const{body:{data:r},url:s}=t;try{const s=wt.Hash.sha256(Buffer.from(r)).toString("hex");await Et.insert({id:s,data:r});const a=`${t.protocol}://${t.get("host")}/store/${s}`;e.status(201).json({_url:a})}catch(t){st.error(`POST ${s} failed with error '${t.message}'`),e.status(500).json({error:t.message})}})),Rt.delete("/:id",(async({params:{id:t},url:e,method:r},s)=>{nt()||(st.error(`Authorization failed at ${r} ${e}.`),s.status(403).json({error:`Authorization failed at ${r} ${e}.`}));try{await Et.delete(t)?s.status(204).send():s.status(403).json({error:"No entry found."})}catch(t){st.error(`DELETE ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}}));class Tt{static async select(){return yt.one('SELECT "syncedHeight", "bitcoindSyncedHeight", "bitcoindSyncedProgress" FROM "Sync"')}static async update({syncedHeight:t,bitcoindSyncedHeight:e,bitcoindSyncedProgress:r}){const s=new d.PreparedStatement({name:`Sync.update.${Math.random()}`,text:'UPDATE "Sync" SET "syncedHeight" = $1, "bitcoindSyncedHeight" = $2, "bitcoindSyncedProgress" = $3',values:[t,e,r]});await yt.any(s)}}var vt=async()=>class{static async select(){return Tt.select()}static async update(t){await Tt.update(t)}}.select();const $t={protocol:et.RPC_PROTOCOL,user:et.RPC_USER,pass:et.RPC_PASSWORD,host:et.RPC_HOST,port:et.RPC_PORT};const Ot=new C.default($t);const bt={createwallet:I.default.promisify(C.default.prototype.createwallet.bind(Ot)),generateToAddress:I.default.promisify(C.default.prototype.generateToAddress.bind(Ot)),getaddressinfo:I.default.promisify(C.default.prototype.getaddressinfo.bind(Ot)),getBlock:I.default.promisify(C.default.prototype.getBlock.bind(Ot)),getBlockchainInfo:I.default.promisify(C.default.prototype.getBlockchainInfo.bind(Ot)),getBlockHash:I.default.promisify(C.default.prototype.getBlockHash.bind(Ot)),getRawTransaction:I.default.promisify(C.default.prototype.getRawTransaction.bind(Ot)),getTransaction:I.default.promisify(C.default.prototype.getTransaction.bind(Ot)),importaddress:I.default.promisify(C.default.prototype.importaddress.bind(Ot)),listunspent:I.default.promisify(C.default.prototype.listunspent.bind(Ot)),sendRawTransaction:I.default.promisify(C.default.prototype.sendRawTransaction.bind(Ot))};class Pt{static async select(t){const e=new d.PreparedStatement({name:`Standard.select.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev" FROM "Standard" WHERE "address" = $1 AND "spent" = FALSE',values:[t]});return(await yt.any(e)).map((t=>({...t,satoshis:parseInt(t.satoshis,10)})))}static async insert(t){const e=t.flatMap((t=>[t.rev,t.address,t.satoshis,t.scriptPubKey,!1]));for(;e.length;){const t=e.splice(0,et.POSTGRES_MAX_PARAM_NUM);const r=[];for(let e=1;e<=t.length;e+=5)r.push(`($${e}, $${e+1}, $${e+2}, $${e+3}, $${e+4})`);const s=r.join(",");const a=new d.PreparedStatement({name:`Standard.insert.${Math.random()}`,text:`INSERT INTO "Standard"("rev", "address", "satoshis", "scriptPubKey", "spent") VALUES ${s}  ON CONFLICT DO NOTHING`,values:t});await yt.none(a)}}static async update(t){const e=t.flatMap((t=>[`${t.prevTxId.toString("hex")}/${t.outputIndex}`]));if(0===e.length)return[];const r=[];for(let t=1;t<=e.length;t+=1)r.push(`("rev" = $${t})`);const s=r.join(" OR ");const a=new d.PreparedStatement({name:`Standard.update.${Math.random()}`,text:`UPDATE "Standard" SET "spent" = TRUE WHERE ${s} RETURNING "rev"`,values:e});return yt.any(a)}static async getBalance(t){const e=new d.PreparedStatement({name:`Standard.getBalance.${Math.random()}`,text:'SELECT SUM("satoshis") FROM "Standard" WHERE "address" = $1 AND "spent" = FALSE',values:[t]});const r=await yt.oneOrNone(e);return parseInt(null==r?void 0:r.sum,10)||0}}class Nt{static async select(t){return(await Pt.select(t)).map((t=>({...t,amount:t.satoshis/1e8})))}static async getBalance(t){return Pt.getBalance(t)}static async insert(t){const e=t.map((t=>({rev:`${t.txId}/${t.outputIndex}`,address:t.address.toString("legacy"),satoshis:t.satoshis,scriptPubKey:t.script.toHex(),spent:!1})));return Pt.insert(e)}}const{Script:_t,Transaction:xt}=c.Bitcoin;const{Transaction:Ct}=c.Bitcoin;const{Input:It}=Ct;class At{static async query(t){const{publicKey:e,classHash:r}=t;if(void 0===e&&void 0===r)return[];let s='SELECT "rev"\n      FROM "NonStandard"\n      WHERE "spent" = FALSE';const a=[];e&&(a.push(e),s+=' AND $1 = ANY ("publicKeys")'),r&&(a.push(r),s+=` AND "classHash" = $${a.length}`);const n=new d.PreparedStatement({name:`NonStandard.query.${Math.random()}`,text:s,values:a});return(await yt.any(n)).map((t=>t.rev))}static async insert({id:t,rev:e,publicKeys:r,classHash:s}){const a=new d.PreparedStatement({name:`NonStandard.insert.${Math.random()}`,text:'INSERT INTO "NonStandard"("id", "rev", "publicKeys", "classHash", "spent") VALUES ($1, $2, $3, $4, FALSE) ON CONFLICT DO NOTHING',values:[t,e,r,s]});await yt.none(a)}static async update(t){const e=new d.PreparedStatement({name:`NonStandard.update.${Math.random()}`,text:'UPDATE "NonStandard" SET "spent" = TRUE WHERE "rev" = $1 AND "spent" = FALSE',values:[t]});return yt.none(e)}static async getRevsByIds(t){const e=new d.PreparedStatement({name:`NonStandard.getRevsByIds.${Math.random()}`,text:'SELECT "rev" FROM "NonStandard" WHERE "id" LIKE ANY($1) AND "spent" = FALSE',values:[[t]]});return yt.any(e)}static async select(t){const e=new d.PreparedStatement({name:`NonStandard.select.${Math.random()}`,text:'SELECT "id", "classHash" FROM "NonStandard" WHERE "rev" = $1',values:[t]});return yt.oneOrNone(e)}}class Ht{static async select(t){return At.select(t)}static async query(t){return At.query(t)}static async getRevsByIds(t){return At.getRevsByIds(t)}static async insert(t){return At.insert(t)}static async update(t){return At.update(t)}}const{crypto:Mt}=c.Bitcoin;class jt{static async getTransaction(t){const{result:e}=await bt.getTransaction(t);return e}static async getBulkTransactions(t){return(await Promise.all(t.map((t=>bt.getRawTransaction(t))))).map((t=>t.result))}static async sendRawTransaction(t){const{result:e,error:r}=await bt.sendRawTransaction(t);if(r)throw st.error(r),new Error("Error sending transaction");return e}}var Lt=async t=>await jt.getBulkTransactions(t);const{CHAIN:Bt,NETWORK:Dt,BCN_URL:Ut}=et;const Ft=new p.Computer({chain:Bt,network:Dt,url:Ut});const kt=t=>t.tx.inputs.map((t=>c.Bitcoin.Transaction.Input.fromObject({...t,script:t._scriptBuffer}))).filter((t=>!t.isNull()));const Gt=async t=>{const e=kt(t);if(e.length>0){const r=await(async t=>{const e=kt(t);let r=[];return e.length>0&&(r=await(async t=>{const e=await class{static async areSpent(t){return class{static async areSpent(t){const e=t.map((t=>`('${t.prevTxId.toString("hex")}/${t.outputIndex}')`)).join(",");const r=new d.PreparedStatement({name:`Utxos.areSpent.${Math.random()}`,text:`SELECT "rev", "stSpent", "nstSpent" from "Utxos"  WHERE "rev" IN (${e})`});return yt.any(r)}}.areSpent(t)}}.areSpent(t);return e})(e)),r})(t);const s=e.flatMap((t=>{const e=`${t.prevTxId.toString("hex")}/${t.outputIndex}`;return r.some((t=>t.rev===e))?[]:[t]}));await Promise.all(s.map((async t=>{try{st.info(`Repairing input:${t.prevTxId.toString("hex")}`);const[e]=await Lt([t.prevTxId.toString("hex")]);const r=await Ft.db.fromHex(e);await Gt(r),st.info(`Repaired successfully input:${t.prevTxId.toString("hex")}`)}catch(e){st.error(`Error on repair input:${t.prevTxId.toString("hex")}`)}})))}await(async(t,e)=>{const r=t.flatMap(((t,r)=>{const s=_t.fromBuffer(t._scriptBuffer);const{PUBKEYHASH_OUT:a,SCRIPTHASH_OUT:n}=_t.types;if(![a,n].includes(s.classify()))return[];const o=s.toAddress(et.NETWORK).toString("legacy");const i=s.toHex();const c=t.satoshis/1e8;const d=Math.round(t.satoshis);return[new xt.UnspentOutput({address:o,txId:e,outputIndex:r,scriptPubKey:i,amount:c,satoshis:d})]}));await Nt.insert(r)})(t.tx.outputs,t.txId),await(async t=>{const e=t.map((t=>It.fromObject({...t,script:t._scriptBuffer}))).filter((t=>!t.isNull()));return Pt.update(e)})(t.tx.inputs);const{inRevs:r=[],outRevs:s=[],outData:a=[]}=t;await(async(t,e,r)=>{const s=Math.max(t.length,e.length);const a=dt(t,s);const n=dt(e,s);const o=(i=n,a.map(((t,e)=>[t,i[e]])));var i;await Promise.all(o.map((async([t,e],s)=>{const{__cls:a="",_owners:n=[]}=r[s]||{};if(null===t&&e)return/^[0-9A-Fa-f]{64}\/\d+$/.test(e),void await Ht.insert({id:e,rev:e,publicKeys:n,classHash:Mt.Hash.sha256(Buffer.from(a)).toString("hex")});if(e&&t){const{id:r="",classHash:s=""}=await Ht.select(t)||{};await Ht.insert({id:r,classHash:s,rev:e,publicKeys:n}),await Ht.update(t)}})))})(r,s,a)};const Wt=async t=>{try{const e=t.toString("hex");st.info(`ZMQ message { rawTx:${e} }`),"dev"===et.BCN_ENV&&x.default.appendFileSync("zmqlog.log",`${e} \r\n`);const r=await Ft.db.fromTxHex(e);try{await Gt(r)}catch(t){st.error(`Error parsing transaction ${t.message} ${t.stack}`)}}catch(t){st.error(`RawTxSubscriber failed with error '${t.message} ${t.stack}'`)}};var qt=async t=>Nt.select(t);var Kt=async t=>(void 0===(await bt.getaddressinfo(t)).result.timestamp&&(st.info(`Importing address: ${t}`),await bt.importaddress(t,!1)),(await bt.listunspent(0,999999,[t])).result);const Vt={protocol:et.RPC_PROTOCOL,user:et.RPC_USER,pass:et.RPC_PASSWORD,host:et.RPC_HOST,port:et.RPC_PORT};const Yt=new C.default(Vt);const zt={};const Jt=JSON.parse(JSON.stringify(C.default.callspec));const Zt={str:t=>t.toString(),string:t=>t.toString(),int:t=>parseFloat(t),float:t=>parseFloat(t),bool:t=>!0===t||"1"===t||1===t||"true"===t||"true"===t.toString().toLowerCase(),obj:t=>"string"==typeof t?JSON.parse(t):t};try{Object.keys(C.default.prototype).forEach((t=>{t&&"function"==typeof C.default.prototype[t]&&(zt[t]=I.default.promisify(C.default.prototype[t].bind(Yt)))}))}catch(t){st.error(`Error occurred while binding RPC methods: ${t.message}`)}const Qt=new g.ec("secp256k1");const Xt=v.default();let te;try{te=$.default.createServer(Xt)}catch(t){throw st.error(`Starting server failed with error '${t.message}'`),t}if(st.info(`Server listening on port ${et.PORT}`),Xt.use(T.default()),"dev"!==et.BCN_ENV){const t=b.default({windowMs:9e5,max:300,standardHeaders:!0,legacyHeaders:!1});Xt.use(t)}Xt.use(R.default.json({limit:"100mb"})),Xt.use(R.default.urlencoded({limit:"100mb",extended:!0})),Xt.use((async(t,e,r)=>{try{const s=t.get("Authentication");if(!s)return void r();const a=(t=>{const e=t.split(" ");if(2!==e.length||"Bearer"!==e[0])throw new Error("Authentication header is invalid.");const r=Buffer.from(e[1],"base64").toString().split(":");if(3!==r.length)throw new Error;return{signature:r[0],publicKey:r[1],timestamp:parseInt(r[2],10)}})(s);const{signature:n,publicKey:o,timestamp:i}=a;if(Date.now()-i>1e3*et.SIGNATURE_FRESHNESS_MINUTES*60)return void e.status(401).json({error:"Signature is too old."});const c=A.default.sha256().update(et.BCN_URL+i).digest("hex");if(!Qt.keyFromPublic(o,"hex").verify(c,n))return void e.status(401).json({error:"The origin and public key pair doesn't match the signature."});e.locals.authToken=a,r()}catch(t){st.error(`Auth failed with error '${t.message}'`),e.status(401).json({error:t.message})}})),Xt.use((({url:t},e,r)=>{if(void 0!==e.locals.authToken)try{let t;try{const e=nt()?"bcn.test.config.json":"bcn.config.json";t=x.default.readFileSync(H.default.join(__dirname,"..","..",e))}catch(t){if(t.message.includes("ENOENT: no such file or directory"))return void r();throw st.error(`Access-list failed with error '${t.message}'`),t}const{blacklist:s,whitelist:a}=JSON.parse(t.toString());if(s&&a)return void e.status(403).json({error:"Cannot enforce blacklist and whitelist at the same time."});const{publicKey:n}=e.locals.authToken;if(a&&!a.includes(n)||s&&s.includes(n))return void e.status(403).json({error:`Public key ${n} is not allowed.`});r()}catch(r){st.error(`Authorization failed at ${t} with error: '${r.message}'`),e.status(403).json({error:r.message})}else r()}));const ee=(()=>{const t=v.default.Router();return t.get("/wallet/:address/utxos",(async({params:t,url:e},r)=>{try{const{address:e}=t;const s=await qt(e);const a=s.map((({satoshis:t,rev:e})=>{const[r,s]=e.split("/");return{amount:t/1e8,txid:r,vout:parseInt(s,10)}}));if(ot()){let t=[];let r=!1;let s=10;do{try{t=await Kt(e)||[],r=!0}catch(t){st.debug(`Retrying to get utxos '${t.message}'`),await ct(1e3),s-=1}}while(!r&&s>0);const n=t.map((({amount:t,txid:e,vout:r})=>({amount:t,txid:e,vout:r})));it(a,n)||(st.error(`Inconsistency on UTXO set calculation for address ${e}.`),st.error(`db utxos ${JSON.stringify(a,null,2)} rpc utxos ${JSON.stringify(n,null,2)}`),st.error(`db utxos length ${a.length} rpc utxos length: ${n.length}`))}r.status(200).json(s)}catch(t){st.error(`GET ${e} failed with error '${t.message}'`),r.status(404).json({error:t.message})}})),t.get("/non-standard-utxos",(async({query:t,url:e},r)=>{try{const e=await(async t=>Ht.query(t))(t);r.status(200).json(e)}catch(t){st.error(`GET ${e} failed with error '${t.messages}'`),r.status(404).json({error:t.message})}})),t.get("/address/:address/balance",(async({params:t,url:e},r)=>{try{const{address:s}=t;const a=await qt(s);const n=await(async t=>Nt.getBalance(t))(s);const o=a.map((({satoshis:t,rev:e})=>{const[r,s]=e.split("/");return{amount:t/1e8,txid:r,vout:parseInt(s,10)}}));if(ot()){let t=[];let r=!1;let a=10;do{try{t=await Kt(s)||[],r=!0}catch(t){st.debug(`Retrying ${e} getStandardUtxosAction: ${t.message}`),await ct(1e3),a-=1}}while(!r&&a>0);const i=1e8*t.reduce(((t,e)=>t+e.amount),0);const c=t.map((({amount:t,txid:e,vout:r})=>({amount:t,txid:e,vout:r})));n===Math.round(i)&&it(o,c)||(st.error(`Inconsistency on balance calculation for address ${s}: dbBalance ${n} rpcBalance: ${i}`),st.error(`db utxos ${o}`),st.error(`rpc utxos: ${JSON.stringify(o)}`))}r.status(200).json(n)}catch(t){st.error(`GET ${e} failed with error '${t.message}'`),r.status(404).json({error:t.message})}})),t.post("/tx/bulk",(async({body:{txIds:t},url:e},r)=>{try{if(void 0===t||0===t.length)return void r.status(500).json({error:"Missing input txIds."});const e=await Lt(t);e?r.status(200).json(e):r.status(404).json({error:"Not found"})}catch(t){st.error(`POST ${e} failed with error '${t.message}'`),r.status(500).json({error:t.message})}})),t.post("/tx/send",(async({body:{rawTx:t},url:e},r)=>{try{const e=await(async t=>jt.sendRawTransaction(t))(t);await Wt(t),r.status(200).json(e)}catch(t){st.error(`POST ${e} failed with error '${t.message}'`),r.status(500).json({error:t.message})}})),t.post("/revs",(async({body:{ids:t},url:e},r)=>{try{if(void 0===t||0===t.length)return void r.status(404).json({error:"Missing input object ids."});const e=await(async t=>(await Ht.getRevsByIds(t)).map((t=>t.rev)))(t);r.status(200).json(e)}catch(t){st.error(`POST ${e} failed with error '${t.message}'`),r.status(404).json({error:t.message})}})),t.post("/rpc",(async({body:t,url:e},r)=>{try{if(!t||!t.method)throw new Error("Please provide appropriate RPC method name");if(!et.ALLOWED_RPC_METHODS.some((e=>e.test(t.method))))throw new Error("Method is not allowed");const e=function(t,e){if(void 0===Jt[t]||null===Jt[t])throw new Error("This RPC method does not exist, or not supported");const r=e.trim().split(" ");const s=Jt[t].trim().split(" ");if(0===e.trim().length&&0!==Jt[t].trim().length)throw new Error(`Too few params provided. Expected ${s.length} Provided 0`);if(0!==e.trim().length&&0===Jt[t].trim().length)throw new Error(`Too many params provided. Expected 0 Provided ${r.length}`);if(r.length<s.length)throw new Error(`Too few params provided. Expected ${s.length} Provided ${r.length}`);if(r.length>s.length)throw new Error(`Too many params provided. Expected ${s.length} Provided ${r.length}`);return 0===e.length?[]:r.map(((t,e)=>Zt[s[e]](t)))}(t.method,t.params);const s=e.length?await zt[t.method](...e):await zt[t.method]();return void r.status(200).json({result:s})}catch(t){st.error(`POST ${e} failed with error '${t.message}'`),r.status(404).json({error:t.message})}})),t.post("/non-standard-utxo",(async(t,e)=>{e.status(500).json({error:"Please upgrade to bitcoin-computer-lib@0.7.7.0-beta or greater."})})),t.get("/tx/:txId",(async({params:t},e)=>{const{txId:r}=t;const[s]=await Lt([r]);s?e.status(200).json(s):e.status(404).json({error:"Not found"})})),t})();Xt.use(`/v1/${et.CHAIN}/${et.NETWORK}`,ee),Xt.use("/v1/store",Rt),Xt.get("/",((t,e)=>e.status(200).send("OK"))),Xt.get("/health",((t,e)=>e.status(200).send("healthy"))),Xt.get("/version",((t,e)=>e.status(200).send(et.SERVER_VERSION))),te.listen(et.PORT,(()=>{st.info(`Rev ${et.SERVER_VERSION} Started web server on port ${et.PORT}`)}));const re=new O.Subscriber;re.connect(et.ZMQ_URL),re.subscribe("rawtx"),st.info(`ZMQ Subscriber connected to ${et.ZMQ_URL}`),(async()=>{await(async()=>{await u.backOff((()=>yt.connect()),{startingDelay:mt})})(),await(async t=>{try{await(async()=>{try{await bt.createwallet(et.DEFAULT_WALLET)}catch(t){st.debug(`Wallet creation failed with error '${t.message}'`)}})(),"regtest"!==et.NETWORK&&await(async()=>{let t=-1;let e=-1;let r=0;st.info("Checking sync progress...syncedHeight: -1 from -1");do{({syncedHeight:t,bitcoindSyncedHeight:e,bitcoindSyncedProgress:r}=await vt()),t>0?st.info(`Sync progress ${t}/${e} blocks [${(t/e*100).toFixed(4)}% (bitcoind progress: ${(100*r).toFixed(4)}%)]`):st.info(`Sync progress initializing... ${t}/${e} blocks `),await ct(et.SYNC_INTERVAL_CHECK)}while(t<e||r<.999);st.info(`BCN reaches sync end...currentBlockHeight: ${t} from ${e} (chain progress: ${(100*r).toFixed(4)})`)})(),st.info("Bitcoin Computer Node is ready");for await(const[,e]of t)await Wt(e)}catch(t){st.error(`ZMQ subscription failed with error '${t.message}'`)}})(re)})();
