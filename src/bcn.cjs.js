"use strict";var t=require("body-parser");var e=require("cors");var a=require("express");var r=require("http");var s=require("zeromq");var n=require("express-rate-limit");var o=require("dotenv");var i=require("winston");var c=require("bitcoin-computer-bitcore");var d=require("pg-promise");var u=require("pg-monitor");var l=require("bitcoind-rpc");var y=require("hash.js");var S=require("util");var f=require("bitcoin-computer-lib");var m=require("elliptic");var g=require("fs");var T=require("path");function R(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}function v(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((function(a){if("default"!==a){var r=Object.getOwnPropertyDescriptor(t,a);Object.defineProperty(e,a,r.get?r:{enumerable:!0,get:function(){return t[a]}})}})),e.default=t,Object.freeze(e)}var h=R(t);var p=R(e);var E=R(a);var w=R(r);var O=v(s);var N=R(n);var $=R(o);var P=R(d);var b=R(u);var _=R(l);var x=R(y);var C=R(S);var I=R(g);var j=R(T);$.default.config();const{PORT:A=3e3,ZMQ_URL:H="tcp://litecoind:28332",CHAIN:U="LTC",NETWORK:B="regtest",BCN_ENV:L="dev",BCN_URL:M="http://127.0.0.1:3000",DEBUG_MODE:G=1,POSTGRES_USER:D="bcn",POSTGRES_PASSWORD:W="bcn",POSTGRES_DB:q="bcn",POSTGRES_HOST:k="127.0.0.1",POSTGRES_PORT:F=5432,RPC_PROTOCOL:K="http",RPC_USER:V="bcn-admin",RPC_PASSWORD:z="kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=",RPC_HOST:Y="litecoind",RPC_PORT:J=19332,SERVER_VERSION:Z=.1,DEFAULT_WALLET:Q="defaultwallet"}=process.env;var X={PORT:A,ZMQ_URL:H,CHAIN:U,NETWORK:B,BCN_ENV:L,BCN_URL:M,DEBUG_MODE:G,POSTGRES_USER:D,POSTGRES_PASSWORD:W,POSTGRES_DB:q,POSTGRES_HOST:k,POSTGRES_PORT:F,POSTGRES_MAX_PARAM_NUM:65535,RPC_PROTOCOL:K,RPC_USER:V,RPC_PASSWORD:z,RPC_HOST:Y,RPC_PORT:J,SYNC_HEIGHT:1,SYNC_INTERVAL_CHECK:3e3,SERVER_VERSION:Z,DB_CONNECTION_RETRY_TIME:3e3,SIGNATURE_FRESHNESS_MINUTES:3,DEFAULT_WALLET:Q};const tt=i.createLogger({level:"info",format:i.format.json(),transports:[new i.transports.File({filename:"error.log",level:"error"}),new i.transports.File({filename:"combined.log"})]});tt.add(new i.transports.Console({format:i.format.combine(i.format.colorize(),i.format.timestamp({format:"YYYY-MM-DD HH:mm:ss"}),i.format.printf((t=>`${t.level} ${t.message} [2m${t.timestamp}[0m`)))}));const et=()=>"dev"===X.BCN_ENV;const at=()=>{const t={protocol:X.RPC_PROTOCOL,user:X.RPC_USER,pass:X.RPC_PASSWORD,host:X.RPC_HOST,port:X.RPC_PORT};return new _.default(t)};const rt=t=>new Promise((e=>{setTimeout(e,t)}));const st={error:(t,e)=>{e.cn&&tt.info(`Connection to db failed: ${JSON.stringify(e.cn)} ${t}`)},noWarnings:!0};et()&&"1"===X.DEBUG_MODE&&(b.default.isAttached()?b.default.detach():(b.default.attach(st),b.default.setTheme("matrix")));const nt=P.default(st)({host:X.POSTGRES_HOST,port:X.POSTGRES_PORT,database:X.POSTGRES_DB,user:X.POSTGRES_USER,password:X.POSTGRES_PASSWORD,allowExitOnIdle:!0,idleTimeoutMillis:100});class ot{static async find(t){const e=new d.PreparedStatement({name:"OffChainStore.find",text:'SELECT "data" FROM "OffChainStore" WHERE "id" = $1',values:[t]});const a=await nt.oneOrNone(e);return a?a.data.toString():a}static async save(t,e){const a=new d.PreparedStatement({name:"OffChainStore.save",text:'INSERT INTO "OffChainStore" ("id", "data") VALUES ($1, $2) ON CONFLICT DO NOTHING',values:[t,e]});return nt.none(a)}static async delete(t){const e=new d.PreparedStatement({name:"OffChainStore.delete",text:'WITH deleted AS (DELETE FROM "OffChainStore" WHERE "id" = $1 RETURNING *) SELECT count(*) FROM deleted;',values:[t]});return(await nt.any(e))[0].count>0}}class it{static async get(t){return ot.find(t)}static async set(t,e){return ot.save(t,e)}static async delete(t){return ot.delete(t)}}const{crypto:ct}=c.Bitcoin;const dt=E.default.Router();dt.get("/:id",(async({params:{id:t},url:e,method:a},r)=>{void 0===r.locals.authToken&&(tt.error(`Authorization failed at ${a} ${e}.`),r.status(403).json({error:`Authorization failed at ${a} ${e}.`}));try{const e=await it.get(t);e?r.status(200).json(e):r.status(403).json({error:"No entry found."})}catch(t){tt.error(`GET ${e} failed with error: ${t.message}`),r.status(500).json({error:t.message})}})),dt.post("/",(async(t,e)=>{const{body:{data:a},url:r}=t;try{const r=ct.Hash.sha256(Buffer.from(a)).toString("hex");await it.set(r,a);const s=`${t.protocol}://${t.get("host")}/store/${r}`;e.status(201).json({_url:s})}catch(t){tt.error(`POST ${r} failed with error: ${t.message}`),e.status(500).json({error:t.message})}})),dt.delete("/:id",(async({params:{id:t},url:e,method:a},r)=>{et()||(tt.error(`Authorization failed at ${a} ${e}.`),r.status(403).json({error:`Authorization failed at ${a} ${e}.`}));try{await it.delete(t)?r.status(204).send():r.status(403).json({error:"No entry found."})}catch(t){tt.error(`${a} ${e} failed with error: ${t.message}`),r.status(500).json({error:t.message})}}));class ut{static async findByRevId(t){const e=new d.PreparedStatement({name:"NonStandardTxo.findByRevId",text:'SELECT "rev", "contractName", "contractHash" FROM "NonStandardTxos" WHERE "rev" = $1',values:[t]});return nt.oneOrNone(e)}static async findManyNonStandardUtxos(t){const{publicKey:e,contractName:a,contractHash:r}=t;if(void 0===e&&void 0===a&&void 0===r)return[];let s='SELECT "rev", "contractName", "contractHash" FROM "NonStandardTxos"';let n=' WHERE "spent" = false';let o="findManyNonStandardUtxos";const i=[];e&&(o+=(0===i.length?"By":"And")+"PublicKey",i.push(e),n+=' AND "publicKey" = $1'),a&&(o+=(0===i.length?"By":"And")+"ContractName",i.push(a),n+=` AND "contractName" = $${i.length}`),r&&(o+=(0===i.length?"By":"And")+"ContractHash",i.push(r),n+=` AND "contractHash" = $${i.length}`),s+=n;const c=new d.PreparedStatement({name:o,text:s,values:i});return nt.any(c)}static async saveNonStandardUtxo(t,e,a,r){const s=new d.PreparedStatement({name:"NonStandardTxo.saveNonStandardUtxo",text:'INSERT INTO "NonStandardTxos"("publicKey", "rev", "spent", "contractName", "contractHash") VALUES ($1, $2, false, $3, $4)',values:[e,t,a,r]});await nt.none(s)}static async updateSpent(t){const e=new d.PreparedStatement({name:"NonStandardTxo.updateSpent",text:'UPDATE "NonStandardTxos" SET "spent" = true WHERE "rev" = $1',values:[t]});await nt.none(e)}}class lt{static async getNonStandardTxoByRevId(t){return ut.findByRevId(t)}static async queryNonStandardUtxos(t){return ut.findManyNonStandardUtxos(t)}static async addNonStandardUtxo(t,e,a,r){return ut.saveNonStandardUtxo(t,e,a,r)}static async updateSpent(t){return ut.updateSpent(t)}}class yt{static async findById(t){const e=new d.PreparedStatement({name:"IdToRev.findById",text:'SELECT "rev" FROM "IdToRev" WHERE id = $1',values:[t]});return nt.any(e)}static async findManyById(t){const e=new d.PreparedStatement({name:"IdToRev.findManyById",text:'SELECT "id", "rev" FROM "IdToRev" WHERE "id" LIKE ANY($1)',values:[[t]]});return nt.any(e)}static async save(t,e){const a=new d.PreparedStatement({name:"IdToRev.save",text:'INSERT INTO "IdToRev" (id, rev) VALUES ($1, $2)',values:[t,e]});await nt.any(a)}static async update(t,e){const a=new d.PreparedStatement({name:"IdToRev.update",text:'UPDATE "IdToRev" SET rev = $1 WHERE rev = $2',values:[t,e]});await nt.any(a)}}class St{static async getRev(t){return yt.findById(t)}static async getRevs(t){const e=await yt.findManyById(t);const a=new Map(e.map((t=>[t.id,t.rev])));return t.map((t=>a.has(t)?a.get(t):null))}static async addRev(t,e){return yt.save(t,e)}static async updateRev(t,e){return yt.update(t,e)}}function ft(t){return function(t){if(!/^[0-9A-Fa-f]{64}\/\d+$/.test(t))throw new Error(`Invalid outId: ${t}`)}(t),{rev:t}}var mt=async(t,e,a)=>{try{if(Array.isArray(e)&&Array.isArray(a)&&t){const s=(t,e)=>Object.assign(new Array(e).fill(null),t);const n=Math.max(e.length,a.length);const o=s(e,n);const i=s(a,n);const c=a.length;const d=(r=i,o.map(((t,e)=>[t,r[e]])));const u=JSON.parse(t);if(u.length!==a.length)return;await Promise.all(d.map((async([t,e],a)=>{const r=u[a];const s=!!t&&!!e;const n=c>0;let o="";let i="";if(null===t&&e){const{__cls:t}=r;t&&(o=(t=>{const e=t.startsWith("export ")?t.slice(7):t;return(e.startsWith("default ")?e.slice(8):e).split(" ")[1]})(t),i=x.default.sha256().update(t).digest("hex")),await St.addRev(e,e)}else if(s){const a=ft(t);const r=await lt.getNonStandardTxoByRevId(a.rev);o=null==r?void 0:r.contractName,i=null==r?void 0:r.contractHash,await St.updateRev(e,t),await lt.updateSpent(a.rev)}if(n){const t=ft(e);await Promise.all(r._owners.map((e=>lt.addNonStandardUtxo(t.rev,e,o,i))))}})))}}catch(t){if(!t.message.includes("duplicate key value violates unique constraint"))throw t}var r};class gt{static async findById(t){const e=new d.PreparedStatement({name:"Transaction.findById",text:'SELECT tx FROM "Transactions" WHERE id = $1',values:[t]});const a=await nt.oneOrNone(e);return null===a?null:a.tx.toString()}static async save(t,e){const a=new d.PreparedStatement({name:"Transaction.save",text:'INSERT INTO "Transactions"(id, tx) VALUES ($1, $2) ON CONFLICT DO NOTHING',values:[t,e]});await nt.none(a)}}class Tt{static async getTransaction(t){return gt.findById(t)}static async getBulkTransactions(t,e,a){return Promise.all(a.map((t=>gt.findById(t))))}static async addTransaction(t,e){await gt.save(t,e)}static async broadcastRawTransaction(t){const e=at();const a=C.default.promisify(_.default.prototype.sendRawTransaction.bind(e));const{result:r}=await a(t);return await this.addTransaction(r,t),r}}var Rt=async t=>await Tt.getTransaction(t);var vt=async t=>{const e=at();const a=C.default.promisify(_.default.prototype.importaddress.bind(e));const r=C.default.promisify(_.default.prototype.getaddressinfo.bind(e));const s=C.default.promisify(_.default.prototype.listunspent.bind(e));return void 0===(await r(t)).result.timestamp&&(tt.info(`Importing address: ${t}`),await a(t,!1)),(await s(0,999999,[t])).result};const{CHAIN:ht,NETWORK:pt,BCN_URL:Et}=X;const wt=new f.Computer({chain:ht,network:pt,url:Et});class Ot{static async getProgress(){return nt.one('SELECT "syncedHeight", "bitcoindSyncedHeight", "bitcoindSyncedProgress" FROM "SyncProgress"')}static async saveProgress(t,e,a){const r=new d.PreparedStatement({name:"SyncProgress.save",text:'UPDATE "SyncProgress" SET "syncedHeight" = $1, "bitcoindSyncedHeight" = $2, "bitcoindSyncedProgress" = $3',values:[t,e,a]});await nt.any(r)}}var Nt=async()=>class{static async getProgress(){return Ot.getProgress()}static async saveProgres(t,e,a){await Ot.saveProgress(t,e,a)}}.getProgress();const $t=async t=>{const e=t.toString("hex");try{tt.info(`Message on topic "rawTx": ${e}`),await(async t=>{let e;let a;let r;let s;try{({inRevs:e,outRevs:a,outData:r,txId:s}=await wt.db.fromTxHex(t))}catch(e){"dev"===X.BCN_ENV&&tt.error(`Error parsing transaction "${t}": ${e}`)}if(r.length)try{await mt(JSON.stringify(r),e,a),await(async(t,e)=>{await Tt.addTransaction(t,e)})(s,t),tt.info(`Synced to "${s}"`)}catch(e){tt.error(`Error syncing to "${t}": ${e}`)}})(e)}catch(t){tt.error(`RawTxSubscriber failed with error: ${t.message}`)}};const Pt=new m.ec("secp256k1");const bt=E.default();let _t;try{_t=w.default.createServer(bt)}catch(t){throw tt.error(`Starting server failed with error: ${t.message}`),t}if(tt.info(`Server listening on port ${X.PORT}`),bt.use(p.default()),"dev"!==X.BCN_ENV){const t=N.default({windowMs:9e5,max:300,standardHeaders:!0,legacyHeaders:!1});bt.use(t)}bt.use(h.default.json({limit:"100mb"})),bt.use(h.default.urlencoded({limit:"100mb",extended:!0})),bt.use((async(t,e,a)=>{try{const r=t.get("Authentication");if(!r)return void a();const s=(t=>{const e=t.split(" ");if(2!==e.length||"Bearer"!==e[0])throw new Error("Authentication header is invalid.");const a=Buffer.from(e[1],"base64").toString().split(":");if(3!==a.length)throw new Error;return{signature:a[0],publicKey:a[1],timestamp:parseInt(a[2],10)}})(r);const{signature:n,publicKey:o,timestamp:i}=s;if(Date.now()-i>1e3*X.SIGNATURE_FRESHNESS_MINUTES*60)return void e.status(401).json({error:"Signature is too old."});const c=x.default.sha256().update(X.BCN_URL+i).digest("hex");if(!Pt.keyFromPublic(o,"hex").verify(c,n))return void e.status(401).json({error:"The origin and public key pair doesn't match the signature."});e.locals.authToken=s,a()}catch(t){e.status(401).json({error:t.message})}})),bt.use((({url:t},e,a)=>{if(void 0!==e.locals.authToken)try{let t;try{const e=et()?"bcn.test.config.json":"bcn.config.json";t=I.default.readFileSync(j.default.join(__dirname,"..","..",e))}catch(t){if(t.message.includes("ENOENT: no such file or directory"))return void a();throw t}const{blacklist:r,whitelist:s}=JSON.parse(t.toString());if(r&&s)return void e.status(403).json({error:"Cannot enfore blacklist and whitelist at the same time."});const{publicKey:n}=e.locals.authToken;if(s&&!s.includes(n)||r&&r.includes(n))return void e.status(403).json({error:`Public key ${n} is not allowed.`});a()}catch(a){tt.error(`Authorization failed at ${t} with error: ${a.message}`),e.status(403).json({error:a.message})}else a()}));const xt=(()=>{const t=E.default.Router();return t.post("/non-standard-utxo",(async({body:t,url:e},a)=>{try{if(!t||"object"!=typeof t)return void a.status(500).json({error:"Parameter must be an object"});const{outData:e,inRevs:r,outRevs:s}=t;await mt(e,r,s),a.status(201).json({status:"Success"})}catch(t){tt.error(`POST ${e} failed with error: ${t.message}`),a.status(500).json({error:t.message})}})),t.get("/wallet/:publicKey/non-standard-utxos",(async({params:t,url:e},a)=>{try{const{publicKey:e}=t;const r=await(async t=>await lt.queryNonStandardUtxos({publicKey:t}))(e);a.status(200).json(r)}catch(t){tt.error(`GET ${e} failed with error: ${t.message}`),a.status(404).json({error:t.message})}})),t.get("/wallet/:address/utxos",(async({params:t,url:e},a)=>{try{const{address:e}=t;const r=await vt(e);a.status(200).json(r)}catch(t){tt.error(`GET ${e} failed with error: ${t.message}`),a.status(404).json({error:t.message})}})),t.get("/non-standard-utxos",(async({query:t,url:e},a)=>{try{const{publicKey:e,contractName:r,contractHash:s}=t;const n=await(async(t,e,a)=>(await lt.queryNonStandardUtxos({publicKey:t,contractName:e,contractHash:a})).map((t=>t.rev)))(e,r,s);a.status(200).json(n)}catch(t){tt.error(`GET ${e} failed with error: ${t.messages}`),a.status(404).json({error:t.message})}})),t.get("/address/:address/balance",(async({params:t,url:e},a)=>{try{const{address:e}=t;const r=(await vt(e)).reduce(((t,e)=>t+e.amount),0);a.status(200).json(1e8*r)}catch(t){tt.error(`GET ${e} failed with error: ${t.message}`),a.status(404).json({error:t.message})}})),t.get("/tx/:txId",(async({params:t,url:e},a)=>{try{const{txId:e}=t;const r=await Rt(e);r?a.status(200).json(r):a.status(404).json({error:"Not found"})}catch(t){tt.error(`GET ${e} failed with error: ${t.message}`),a.status(500).json({error:t.message})}})),t.get("/tx-data/:txId",(async({params:t,url:e},a)=>{try{const{txId:e}=t;const r=await Rt(e);r?a.status(200).json({hex:r}):a.status(404).json({error:"Not found"})}catch(t){tt.error(`GET ${e} failed with error: ${t.message}`),a.status(500).json({error:t.message})}})),t.post("/tx/bulk",(async({params:t,body:{txIds:e},url:a},r)=>{try{if(void 0===e||0===e.length)return void r.status(500).json({error:"Missing input txIds."});const{chain:a,network:s}=t;const n=await(async(t,e,a)=>await Tt.getBulkTransactions(t,e,a))(a,s,e);n?r.status(200).json(n):r.status(404).json({error:"Not found"})}catch(t){tt.error(`POST ${a} failed with error: ${t.message}`),r.status(500).json({error:t.message})}})),t.post("/tx/send",(async({body:{rawTx:t},url:e},a)=>{try{const e=await(async t=>await Tt.broadcastRawTransaction(t))(t);a.status(200).json(e)}catch(t){tt.error(`POST ${e} failed with error: ${t.message}`),a.status(500).json({error:t.message})}})),t.get("/rev/:id/:outNum",(async({params:t,url:e},a)=>{try{const{id:e,outNum:r}=t;const s=await(async t=>await St.getRev(t))(`${e}/${r}`);a.status(200).json(s)}catch(t){tt.error(`GET ${e} failed with error: ${t.message}`),a.status(404).json({error:t.message})}})),t.post("/revs",(async({body:{ids:t},url:e},a)=>{try{if(void 0===t||0===t.length)return void a.status(404).json({error:"Missing input object ids."});const e=await(async t=>await St.getRevs(t))(t);a.status(200).json(e)}catch(t){tt.error(`POST ${e} failed with error: ${t.message}`),a.status(404).json({error:t.message})}})),t})();bt.use(`/v1/${X.CHAIN}/${X.NETWORK}`,xt),bt.use("/v1/store",dt),bt.get("/",((t,e)=>e.status(200).send("OK"))),bt.get("/health",((t,e)=>e.status(200).send("healthy"))),_t.listen(X.PORT,(()=>{tt.info(`Rev ${X.SERVER_VERSION} Started web server on port ${X.PORT}`)}));const Ct=new O.Subscriber;Ct.connect(X.ZMQ_URL),Ct.subscribe("raw"),tt.info(`ZMQ Subscriber connected to ${X.ZMQ_URL}`),(async()=>{let t=!1;do{try{await nt.connect(),t=!0}catch(t){tt.info(`Re-trying db connection: HOST=${X.POSTGRES_HOST}, PORT=${X.POSTGRES_PORT}, DATABASE=${X.POSTGRES_DB} USER=${X.POSTGRES_USER}`)}await rt(X.DB_CONNECTION_RETRY_TIME)}while(!t)})().then((()=>{(async t=>{try{await(async()=>{try{const t=at();const e=C.default.promisify(_.default.prototype.createwallet.bind(t));const a=await e(X.DEFAULT_WALLET);tt.info(`Wallet created succesfully: ${JSON.stringify(a)}`)}catch(t){tt.info(`Create wallet status: ${JSON.stringify(t,null,2)}`)}})(),"regtest"!==X.NETWORK&&await(async()=>{let t={};let e=-1;let a=-1;let r=0;tt.info(`Checking sync progress...syncedHeight: ${e} from ${a}`);do{t=await Nt(),e=t.syncedHeight,a=t.bitcoindSyncedHeight,r=t.bitcoindSyncedProgress,e>0?tt.info(`Sync progress ${e}/${a} blocks [${(e/a*100).toFixed(4)}% (bitcoind progress: ${(100*r).toFixed(4)}%)]`):tt.info(`Sync progress initializing... ${e}/${a} blocks `),await rt(X.SYNC_INTERVAL_CHECK)}while(e<a||r<.999);tt.info(`BCN reaches sync end...currentBlockHeight: ${e} from ${a} (chain progress: ${(100*r).toFixed(4)})`)})(),tt.info("Waiting for zmq messages...");for await(const[e,a]of t)"rawtx"===e.toString()&&$t(a),"rawblock"===e.toString()&&tt.info(`rawblock msg: ${a}`)}catch(t){tt.error(`run zmqSock failed with error: ${t.message}`)}})(Ct)}));
