"use strict";var t=require("body-parser");var e=require("cors");var a=require("express");var r=require("http");var s=require("zeromq");var n=require("express-rate-limit");var o=require("dotenv");var i=require("winston");var c=require("bitcoin-computer-bitcore");var d=require("pg-promise");var u=require("pg-monitor");var l=require("bitcoind-rpc");var S=require("crypto");var y=require("util");var f=require("bitcoin-computer-lib");var m=require("hash.js");var p=require("elliptic");var g=require("fs");var h=require("path");function T(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}function v(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((function(a){if("default"!==a){var r=Object.getOwnPropertyDescriptor(t,a);Object.defineProperty(e,a,r.get?r:{enumerable:!0,get:function(){return t[a]}})}})),e.default=t,Object.freeze(e)}var R=T(t);var E=T(e);var O=T(a);var w=T(r);var $=v(s);var N=T(n);var x=T(o);var P=T(d);var b=T(u);var _=T(l);var B=T(S);var C=T(y);var I=T(m);var A=T(g);var U=T(h);x.default.config();const{PORT:M=3e3,ZMQ_URL:j="tcp://litecoind:28332",CHAIN:H="LTC",NETWORK:L="regtest",BCN_ENV:G="dev",BCN_URL:D="http://127.0.0.1:3000",DEBUG_MODE:K=1,POSTGRES_USER:W="bcn",POSTGRES_PASSWORD:F="bcn",POSTGRES_DB:q="bcn",POSTGRES_HOST:k="127.0.0.1",POSTGRES_PORT:V=5432,RPC_PROTOCOL:z="http",RPC_USER:Y="bcn-admin",RPC_PASSWORD:J="kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=",RPC_HOST:Z="litecoind",RPC_PORT:Q=19332,SERVER_VERSION:X=.1,DEFAULT_WALLET:tt="defaultwallet"}=process.env;var et={PORT:M,ZMQ_URL:j,CHAIN:H,NETWORK:L,BCN_ENV:G,BCN_URL:D,DEBUG_MODE:K,POSTGRES_USER:W,POSTGRES_PASSWORD:F,POSTGRES_DB:q,POSTGRES_HOST:k,POSTGRES_PORT:V,POSTGRES_MAX_PARAM_NUM:1e4,RPC_PROTOCOL:z,RPC_USER:Y,RPC_PASSWORD:J,RPC_HOST:Z,RPC_PORT:Q,SYNC_HEIGHT:1,SYNC_INTERVAL_CHECK:3e3,SERVER_VERSION:X,DB_CONNECTION_RETRY_TIME:3e3,SIGNATURE_FRESHNESS_MINUTES:3,DEFAULT_WALLET:tt};const at=i.createLogger({level:"info",format:i.format.json(),transports:[new i.transports.File({filename:"error.log",level:"error"}),new i.transports.File({filename:"combined.log"})]});at.add(new i.transports.Console({format:i.format.combine(i.format.colorize(),i.format.timestamp({format:"YYYY-MM-DD HH:mm:ss"}),i.format.printf((t=>`${t.level} ${t.message} [2m${t.timestamp}[0m`)))}));const{PublicKey:rt}=c.Bitcoin;const st=()=>"dev"===et.BCN_ENV;const nt=()=>et.DEBUG_MODE>0;const ot=()=>et.DEBUG_MODE>1;const it=(t,e)=>{if(t.length!==e.length)return!1;for(let a=0;a<t.length;a++){const r=t[a];const s=Object.keys(r);let n=!1;for(let t=0;t<e.length;t++){const a=e[t];const o=Object.keys(a);if(s.length===o.length&&s.every((t=>o.includes(t)))&&s.every((t=>r[t]===a[t]))){n=!0;break}}if(!n)return!1}return!0};const ct=()=>{const t={protocol:et.RPC_PROTOCOL,user:et.RPC_USER,pass:et.RPC_PASSWORD,host:et.RPC_HOST,port:et.RPC_PORT};return new _.default(t)};const dt=t=>new Promise((e=>{setTimeout(e,t)}));const ut=t=>t.isPublicKeyOut()?new rt(t.getPublicKey()).toAddress(et.NETWORK).toString("legacy"):t.toAddress(et.NETWORK).toString("legacy");const lt={error:(t,e)=>{e.cn&&at.info(`Connection to db failed: ${JSON.stringify(e.cn)} ${t}`)},noWarnings:!0};st()&&nt()&&(b.default.isAttached()?b.default.detach():(b.default.attach(lt),b.default.setTheme("matrix")));const St=P.default(lt)({host:et.POSTGRES_HOST,port:et.POSTGRES_PORT,database:et.POSTGRES_DB,user:et.POSTGRES_USER,password:et.POSTGRES_PASSWORD,allowExitOnIdle:!0,idleTimeoutMillis:100});class yt{static async find(t){const e=new d.PreparedStatement({name:"OffChainStore.find",text:'SELECT "data" FROM "OffChainStore" WHERE "id" = $1',values:[t]});const a=await St.oneOrNone(e);return a?a.data.toString():a}static async save(t,e){const a=new d.PreparedStatement({name:"OffChainStore.save",text:'INSERT INTO "OffChainStore" ("id", "data") VALUES ($1, $2) ON CONFLICT DO NOTHING',values:[t,e]});return St.none(a)}static async delete(t){const e=new d.PreparedStatement({name:"OffChainStore.delete",text:'WITH deleted AS (DELETE FROM "OffChainStore" WHERE "id" = $1 RETURNING *) SELECT count(*) FROM deleted;',values:[t]});return(await St.any(e))[0].count>0}}class ft{static async get(t){return yt.find(t)}static async set(t,e){return yt.save(t,e)}static async delete(t){return yt.delete(t)}}const{crypto:mt}=c.Bitcoin;const pt=O.default.Router();pt.get("/:id",(async({params:{id:t},url:e,method:a},r)=>{void 0===r.locals.authToken&&(at.error(`Authorization failed at ${a} ${e}.`),r.status(403).json({error:`Authorization failed at ${a} ${e}.`}));try{const e=await ft.get(t);e?r.status(200).json(e):r.status(403).json({error:"No entry found."})}catch(t){at.error(`GET ${e} failed with error: ${t.message}`),r.status(500).json({error:t.message})}})),pt.post("/",(async(t,e)=>{const{body:{data:a},url:r}=t;try{const r=mt.Hash.sha256(Buffer.from(a)).toString("hex");await ft.set(r,a);const s=`${t.protocol}://${t.get("host")}/store/${r}`;e.status(201).json({_url:s})}catch(t){at.error(`POST ${r} failed with error: ${t.message}`),e.status(500).json({error:t.message})}})),pt.delete("/:id",(async({params:{id:t},url:e,method:a},r)=>{st()||(at.error(`Authorization failed at ${a} ${e}.`),r.status(403).json({error:`Authorization failed at ${a} ${e}.`}));try{await ft.delete(t)?r.status(204).send():r.status(403).json({error:"No entry found."})}catch(t){at.error(`${a} ${e} failed with error: ${t.message}`),r.status(500).json({error:t.message})}}));class gt{static async countByRev(t){if(!t.length)return 0;let e=t.map((t=>`('${t.prevTxId.toString("hex")}/${t.outputIndex}')`)).join(",");e=`(  ${e} )`;const a=new d.PreparedStatement({name:`NonStandardTxos.countByRev$${B.default.randomBytes(10).toString("hex")}`,text:`SELECT count("rev") FROM "NonStandardTxos" WHERE "rev" IN ${e}`});const r=await St.oneOrNone(a);return parseInt(null==r?void 0:r.count,10)||0}static async findNonStandardTxoByRev(t){const e=new d.PreparedStatement({name:"NonStandardTxo.findNonStandardTxoByRev",text:'SELECT "rev", "contractName", "contractHash" FROM "NonStandardTxos" WHERE "rev" = $1',values:[t]});return St.oneOrNone(e)}static async findRevById(t){const e=new d.PreparedStatement({name:"NonStandardTxo.findRevById",text:'SELECT "rev" FROM "NonStandardTxos" WHERE "id" = $1',values:[t]});return St.any(e)}static async findManyNonStandardUtxosRevsById(t){const e=new d.PreparedStatement({name:"NonStandardTxo.findManyRevsById",text:'SELECT "rev" FROM "NonStandardTxos" WHERE "id" LIKE ANY($1)',values:[[t]]});return St.any(e)}static async findManyNonStandardUtxos(t){const{publicKey:e,contractName:a,contractHash:r}=t;if(void 0===e&&void 0===a&&void 0===r)return[];let s='SELECT "rev", "contractName", "contractHash" FROM "NonStandardTxos"';let n=' WHERE "rev" IS NOT NULL';let o="findManyNonStandardUtxos";const i=[];e&&(o+=(0===i.length?"By":"And")+"PublicKeys",i.push(e),n+=' AND $1 = ANY ("publicKeys")'),a&&(o+=(0===i.length?"By":"And")+"ContractName",i.push(a),n+=` AND "contractName" = $${i.length}`),r&&(o+=(0===i.length?"By":"And")+"ContractHash",i.push(r),n+=` AND "contractHash" = $${i.length}`),s+=n;const c=new d.PreparedStatement({name:o,text:s,values:i});return St.any(c)}static async saveNonStandardUtxo(t,e,a,r,s){const n=new d.PreparedStatement({name:"NonStandardTxo.saveNonStandardUtxo",text:'INSERT INTO "NonStandardTxos"("id", "rev", "publicKeys", "contractName", "contractHash") VALUES ($1, $2, $3, $4, $5)',values:[t,e,a,r,s]});await St.none(n)}static async updateNonStandardTxo(t,e,a){const r=new d.PreparedStatement({name:"NonStandardTxo.updateNonStandardTxo",text:'UPDATE "NonStandardTxos" SET "rev" = $1, "publicKeys" = $3 WHERE "rev" = $2',values:[t,e,a]});await St.none(r)}}class ht{static async getNonStandardTxoByRevId(t){return gt.findNonStandardTxoByRev(t)}static async queryNonStandardUtxos(t){return gt.findManyNonStandardUtxos(t)}static async getRev(t){return gt.findRevById(t)}static async getRevs(t){return gt.findManyNonStandardUtxosRevsById(t)}static async addNonStandardUtxo(t,e,a,r,s){return gt.saveNonStandardUtxo(t,e,a,r,s)}static async updateNonStandardTxo(t,e,a){return gt.updateNonStandardTxo(t,e,a)}static async getCount(t){return gt.countByRev(t)}}class Tt{static async countByTxIdVout(t){if(!t.length)return 0;let e=t.map((t=>`('${t.prevTxId.toString("hex")}/${t.outputIndex}')`)).join(",");e=`( ${e} )`;const a=new d.PreparedStatement({name:`StandardUtxos.countByTxIdVout$${B.default.randomBytes(10).toString("hex")}`,text:`SELECT count("rev") FROM "StandardUtxos" WHERE "rev" IN ${e}`});const r=await St.oneOrNone(a);return parseInt(null==r?void 0:r.count,10)||0}static async findManyByAddress(t){const e=new d.PreparedStatement({name:"StandardUtxos.findManyByAddress",text:'SELECT "address", ("satoshis"/100000000.0) AS "amount", "satoshis", "scriptPubKey", "rev" FROM "StandardUtxos" WHERE "address" = $1',values:[t]});return(await St.any(e)).map((t=>({...t,amount:parseFloat(t.amount),satoshis:parseInt(t.satoshis,10)})))}static async getBalance(t){const e=new d.PreparedStatement({name:"StandardUtxos.getBalance",text:'SELECT SUM("satoshis") FROM "StandardUtxos" WHERE "address" = $1',values:[t]});const a=await St.oneOrNone(e);return parseInt(null==a?void 0:a.sum,10)||0}static async saveBatch(t){const e=t.flatMap((t=>[`${t.txId}/${t.outputIndex}`,t.address.toString("legacy"),t.satoshis,t.script.toHex()]));for(;e.length;){const t=e.splice(0,et.POSTGRES_MAX_PARAM_NUM);const a=[];for(let e=1;e<=t.length;e+=4)a.push(`($${e}, $${e+1}, $${e+2}, $${e+3})`);const r=a.join(",");const s=new d.PreparedStatement({name:`StandardUtxos.saveBatch$${B.default.randomBytes(10).toString("hex")}`,text:`INSERT INTO "StandardUtxos"("rev", "address", "satoshis", "scriptPubKey") VALUES ${r}  ON CONFLICT DO NOTHING`,values:t});await St.none(s)}}static async deleteSpentBatch(t){const e=t.flatMap((t=>[`${t.prevTxId.toString("hex")}/${t.outputIndex}`]));const a=et.POSTGRES_MAX_PARAM_NUM;for(;e.length;){const t=e.splice(0,a);const r=[];for(let e=1;e<=t.length;e+=1)r.push(`("rev" = $${e})`);const s=r.join(" OR ");const n=new d.PreparedStatement({name:`StandardUtxos.deleteSpentBatch${B.default.randomBytes(10).toString("hex")}`,text:`DELETE FROM "StandardUtxos" WHERE ${s}`,values:t});await St.none(n)}}}class vt{static async getUtxosFromAddress(t){return Tt.findManyByAddress(t)}static async getBalance(t){return Tt.getBalance(t)}static async getCount(t){return Tt.countByTxIdVout(t)}}var Rt=async t=>await vt.getUtxosFromAddress(t);const Et=ct();const Ot=C.default.promisify(_.default.prototype.getRawTransaction.bind(Et));const wt=C.default.promisify(_.default.prototype.sendRawTransaction.bind(Et));class $t{static async getTransaction(t){const{result:e}=await Ot(t);return e}static async getBulkTransactions(t){return(await Promise.all(t.map((t=>Ot(t))))).map((t=>t.result))}static async broadcastRawTransaction(t){const{result:e}=await wt(t);return e}}var Nt=async t=>{const e=ct();const a=C.default.promisify(_.default.prototype.importaddress.bind(e));const r=C.default.promisify(_.default.prototype.getaddressinfo.bind(e));const s=C.default.promisify(_.default.prototype.listunspent.bind(e));return void 0===(await r(t)).result.timestamp&&(at.info(`Importing address: ${t}`),await a(t,!1)),(await s(0,999999,[t])).result};function xt(t){if(!/^[0-9A-Fa-f]{64}\/\d+$/.test(t))throw new Error(`Invalid outId: ${t}`)}const Pt=(t,e)=>Object.assign(new Array(e).fill(null),t);var bt=async(t,e,a)=>{if(Array.isArray(e)&&Array.isArray(a)&&t){const s=Math.max(e.length,a.length);const n=Pt(e,s);const o=Pt(a,s);const i=(r=o,n.map(((t,e)=>[t,r[e]])));if(t.length!==a.length)return;await Promise.all(i.map((async([e,a],r)=>{const{__cls:s="",_owners:n=[]}=t[r];const o=!!e&&!!a;if(null===e&&a){const t=(t=>{if(!t.length)return"";const e=t.startsWith("export ")?t.slice(7):t;return(e.startsWith("default ")?e.slice(8):e).split(" ")[1]})(s);const e=I.default.sha256().update(s).digest("hex");xt(a),await ht.addNonStandardUtxo(a,a,n,t,e)}else o&&(xt(e),await ht.updateNonStandardTxo(a,e,n))})))}var r};const{Transaction:_t}=c.Bitcoin;const{Input:Bt}=_t;const{Script:Ct,Transaction:It}=c.Bitcoin;const{UnspentOutput:At}=It;class Ut{static async getProgress(){return St.one('SELECT "syncedHeight", "bitcoindSyncedHeight", "bitcoindSyncedProgress" FROM "SyncProgress"')}static async saveProgress(t,e,a){const r=new d.PreparedStatement({name:"SyncProgress.save",text:'UPDATE "SyncProgress" SET "syncedHeight" = $1, "bitcoindSyncedHeight" = $2, "bitcoindSyncedProgress" = $3',values:[t,e,a]});await St.any(r)}}var Mt=async()=>class{static async getProgress(){return Ut.getProgress()}static async saveProgres(t,e,a){await Ut.saveProgress(t,e,a)}}.getProgress();const{Transaction:jt}=c.Bitcoin;const{Input:Ht}=jt;const{CHAIN:Lt,NETWORK:Gt,BCN_URL:Dt}=et;const Kt=new f.Computer({chain:Lt,network:Gt,url:Dt});const Wt=async t=>{try{const e=t.toString("hex");at.info(`Message on topic "rawTx": ${e}`);const a=await Kt.db.fromTxHex(e);await(async t=>{const e=t.map((t=>Ht.fromObject({...t,script:t._scriptBuffer}))).filter((t=>!t.isNull()));const a=await(async t=>await vt.getCount(t))(e);const r=await(async t=>await ht.getCount(t))(e);return a+r<e.length})(a.tx.inputs)||(await(async t=>{for(let e=0;e<t.length;e+=1)try{const{inRevs:a,outRevs:r,outData:s,txId:n}=t[e];if(!(null==s?void 0:s.length))return;await bt(s,a,r),at.info(`Synced to "${n}"`)}catch(a){at.error(`Failed processing ${JSON.stringify(t[e])} because of ${a.message}`)}})([a]),await(async t=>{const e=t.flatMap((({tx:t})=>t.inputs));const a=t.flatMap((({tx:t})=>t.outputs.map(((e,a)=>{const r=e;return r.txId=t.id,r.n=a,r}))));await(async t=>{try{const e=t.filter((t=>{try{const e=Ct.fromBuffer(t._scriptBuffer);return e.isPublicKeyHashOut()||e.isPublicKeyOut()}catch(t){return!1}})).map((t=>{const e=Ct.fromBuffer(t._scriptBuffer);return new At({address:ut(e),txId:t.txId,outputIndex:t.n,scriptPubKey:e.toHex(),amount:t._satoshis/1e8,satoshis:Math.round(t._satoshis)})}));return Tt.saveBatch(e)}catch(t){if(!t.message.includes("duplicate key value violates unique constraint"))throw t;return Promise.resolve(void 0)}})(a),await(async t=>{const e=t.map((t=>Bt.fromObject({...t,script:t._scriptBuffer}))).filter((t=>!t.isNull()));return Tt.deleteSpentBatch(e)})(e)})([a]))}catch(t){at.error(`RawTxSubscriber failed with error: ${t.message}`)}};const Ft=new p.ec("secp256k1");const qt=O.default();let kt;try{kt=w.default.createServer(qt)}catch(t){throw at.error(`Starting server failed with error: ${t.message}`),t}if(at.info(`Server listening on port ${et.PORT}`),qt.use(E.default()),"dev"!==et.BCN_ENV){const t=N.default({windowMs:9e5,max:300,standardHeaders:!0,legacyHeaders:!1});qt.use(t)}qt.use(R.default.json({limit:"100mb"})),qt.use(R.default.urlencoded({limit:"100mb",extended:!0})),qt.use((async(t,e,a)=>{try{const r=t.get("Authentication");if(!r)return void a();const s=(t=>{const e=t.split(" ");if(2!==e.length||"Bearer"!==e[0])throw new Error("Authentication header is invalid.");const a=Buffer.from(e[1],"base64").toString().split(":");if(3!==a.length)throw new Error;return{signature:a[0],publicKey:a[1],timestamp:parseInt(a[2],10)}})(r);const{signature:n,publicKey:o,timestamp:i}=s;if(Date.now()-i>1e3*et.SIGNATURE_FRESHNESS_MINUTES*60)return void e.status(401).json({error:"Signature is too old."});const c=I.default.sha256().update(et.BCN_URL+i).digest("hex");if(!Ft.keyFromPublic(o,"hex").verify(c,n))return void e.status(401).json({error:"The origin and public key pair doesn't match the signature."});e.locals.authToken=s,a()}catch(t){e.status(401).json({error:t.message})}})),qt.use((({url:t},e,a)=>{if(void 0!==e.locals.authToken)try{let t;try{const e=st()?"bcn.test.config.json":"bcn.config.json";t=A.default.readFileSync(U.default.join(__dirname,"..","..",e))}catch(t){if(t.message.includes("ENOENT: no such file or directory"))return void a();throw t}const{blacklist:r,whitelist:s}=JSON.parse(t.toString());if(r&&s)return void e.status(403).json({error:"Cannot enfore blacklist and whitelist at the same time."});const{publicKey:n}=e.locals.authToken;if(s&&!s.includes(n)||r&&r.includes(n))return void e.status(403).json({error:`Public key ${n} is not allowed.`});a()}catch(a){at.error(`Authorization failed at ${t} with error: ${a.message}`),e.status(403).json({error:a.message})}else a()}));const Vt=(()=>{const t=O.default.Router();return t.get("/wallet/:publicKey/non-standard-utxos",(async({params:t,url:e},a)=>{try{const{publicKey:e}=t;const r=await(async t=>await ht.queryNonStandardUtxos({publicKey:t}))(e);a.status(200).json(r)}catch(t){at.error(`GET ${e} failed with error: ${t.message}`),a.status(404).json({error:t.message})}})),t.get("/wallet/:address/utxos",(async({params:t,url:e},a)=>{try{const{address:e}=t;const r=await Rt(e);const s=r.map((({amount:t,rev:e})=>{const[a,r]=e.split("/");return{amount:t,txid:a,vout:parseInt(r,10)}}));if(nt()){const t=(await Nt(e)).map((({amount:t,txid:e,vout:a})=>({amount:t,txid:e,vout:a})));it(s,t)||(at.error(`Inconsistency on UTXO set calculation for address ${e}.`),at.error(`db utxos ${JSON.stringify(s,null,2)} rpc utxos: ${JSON.stringify(t,null,2)}`),ot()&&process.abort())}a.status(200).json(r)}catch(t){at.error(`GET ${e} failed with error: ${t.message}`),a.status(404).json({error:t.message})}})),t.get("/non-standard-utxos",(async({query:t,url:e},a)=>{try{const{publicKey:e,contractName:r,contractHash:s}=t;const n=await(async(t,e,a)=>(await ht.queryNonStandardUtxos({publicKey:t,contractName:e,contractHash:a})).map((t=>t.rev)))(e,r,s);a.status(200).json(n)}catch(t){at.error(`GET ${e} failed with error: ${t.messages}`),a.status(404).json({error:t.message})}})),t.get("/address/:address/balance",(async({params:t,url:e},a)=>{try{const{address:e}=t;const r=await Rt(e);const s=await(async t=>await vt.getBalance(t))(e);const n=r.map((({amount:t,rev:e})=>{const[a,r]=e.split("/");return{amount:t,txid:a,vout:parseInt(r,10)}}));if(nt()){const t=await Nt(e);const a=1e8*t.reduce(((t,e)=>t+e.amount),0);const r=t.map((({amount:t,txid:e,vout:a})=>({amount:t,txid:e,vout:a})));s===Math.round(a)&&it(n,r)||(at.error(`Inconsistency on balance calculation for address ${e}: dbBalance ${s} rpcBalance: ${a}`),at.error(`db utxos ${JSON.stringify(n,null,2)} rpc utxos: ${JSON.stringify(r,null,2)}`),ot()&&process.abort())}a.status(200).json(s)}catch(t){at.error(`GET ${e} failed with error: ${t.message}`),a.status(404).json({error:t.message})}})),t.get("/tx/:txId",(async({params:t,url:e},a)=>{try{const{txId:e}=t;const r=await(async t=>await $t.getTransaction(t))(e);r&&a.status(200).json(r)}catch(t){at.error(`GET ${e} failed with error: ${t.message}`),a.status(500).json({error:t.message})}})),t.post("/tx/bulk",(async({body:{txIds:t},url:e},a)=>{try{if(void 0===t||0===t.length)return void a.status(500).json({error:"Missing input txIds."});const e=await(async t=>await $t.getBulkTransactions(t))(t);e?a.status(200).json(e):a.status(404).json({error:"Not found"})}catch(t){at.error(`POST ${e} failed with error: ${t.message}`),a.status(500).json({error:t.message})}})),t.post("/tx/send",(async({body:{rawTx:t},url:e},a)=>{try{const e=await(async t=>await $t.broadcastRawTransaction(t))(t);a.status(200).json(e)}catch(t){at.error(`POST ${e} failed with error: ${t.message}`),a.status(500).json({error:t.message})}})),t.get("/rev/:id/:outNum",(async({params:t,url:e},a)=>{try{const{id:e,outNum:r}=t;const s=await(async t=>ht.getRev(t))(`${e}/${r}`);a.status(200).json(s)}catch(t){at.error(`GET ${e} failed with error: ${t.message}`),a.status(404).json({error:t.message})}})),t.post("/revs",(async({body:{ids:t},url:e},a)=>{try{if(void 0===t||0===t.length)return void a.status(404).json({error:"Missing input object ids."});const e=await(async t=>(await ht.getRevs(t)).map((t=>t.rev)))(t);a.status(200).json(e)}catch(t){at.error(`POST ${e} failed with error: ${t.message}`),a.status(404).json({error:t.message})}})),t.post("/non-standard-utxo",(async(t,e)=>{e.status(500).json({error:"Please upgrade to bitcoin-computer-lib@0.7.7.0-beta or greater."})})),t})();qt.use(`/v1/${et.CHAIN}/${et.NETWORK}`,Vt),qt.use("/v1/store",pt),qt.get("/",((t,e)=>e.status(200).send("OK"))),qt.get("/health",((t,e)=>e.status(200).send("healthy"))),kt.listen(et.PORT,(()=>{at.info(`Rev ${et.SERVER_VERSION} Started web server on port ${et.PORT}`)}));const zt=new $.Subscriber;zt.connect(et.ZMQ_URL),zt.subscribe("rawtx"),at.info(`ZMQ Subscriber connected to ${et.ZMQ_URL}`),(async()=>{let t=!1;do{try{await St.connect(),t=!0}catch(t){at.info(`Re-trying db connection: HOST=${et.POSTGRES_HOST}, PORT=${et.POSTGRES_PORT}, DATABASE=${et.POSTGRES_DB} USER=${et.POSTGRES_USER}`)}await dt(et.DB_CONNECTION_RETRY_TIME)}while(!t)})().then((()=>{(async t=>{try{"regtest"!==et.NETWORK&&await(async()=>{let t=-1;let e=-1;let a=0;at.info("Checking sync progress...syncedHeight: -1 from -1");do{({syncedHeight:t,bitcoindSyncedHeight:e,bitcoindSyncedProgress:a}=await Mt()),t>0?at.info(`Sync progress ${t}/${e} blocks [${(t/e*100).toFixed(4)}% (bitcoind progress: ${(100*a).toFixed(4)}%)]`):at.info(`Sync progress initializing... ${t}/${e} blocks `),await dt(et.SYNC_INTERVAL_CHECK)}while(t<e||a<.999);at.info(`BCN reaches sync end...currentBlockHeight: ${t} from ${e} (chain progress: ${(100*a).toFixed(4)})`)})(),at.info("Waiting for zmq messages...");for await(const[,e]of t)await Wt(e)}catch(t){at.error(`run zmqSock failed with error: ${t.message}`)}})(zt)}));
